---
title: "Quarterly Collisions in Bloor, University, Danforth, and Yonge"
subtitle: "R Code"
author:
- "Richard Wen richard.wen@utoronto.ca"
date: "`r format(Sys.time(), '%B %d, %Y')`"
knit: |
    (function(input_rmd, ...) {
    rmarkdown::render(
        input_rmd,
        rmarkdown::html_document(
            toc = TRUE,
            toc_float = TRUE,
            highlight = "zenburn",
            code_folding = "hide",
            df_print = "paged",
            self_contained = FALSE
        ),
        output_dir = "../../docs/archive/collisions-bloorunidanyonge",
        output_file = "index", ...)
    })
---

```{r include = FALSE, echo = FALSE}
knitr::opts_chunk$set(
	warning = FALSE,
	message = FALSE
)
```

# Libraries

Load libraries, the main ones being used are `ggplot2` for plotting, `leaflet` and `tmap` for interactive maps, `sf` for spatial data processing, `tidyverse` for data processing, and `DT` for interactive tables.

```{r}

# Load libraries
library(ggplot2)
library(leaflet)
library(leaflet.extras)
library(lubridate)
library(sf)
library(glue)
library(tidyverse)
library(tmap)
library(DT)

```

# Functions

Create a function to assign default behaviour for our `DT` datatables.

```{r}

# Function for default datatable params
datatable <- function(...) {
    
    # Build arg list
    args <- list(...)
    
    # Default custom filename
    filename <- if (!"filename" %in% names(args)) "data" else args$filename
    args[["filename"]] <- NULL
    
    # Add default extensions
    args$extensions <- if (!"extensions" %in% names(args)) "Buttons" else args$extensions
    
    # Add default args
    args$filter <- if (!"filter" %in% names(args)) "top" else args$filter
    args$fillContainer <- if (!"fillContainer" %in% names(args)) T else args$fillContainer
    
    # Add default options
    if (!"options" %in% names(args)) {
        args$options <-  list(
            scrollY = "350px",
            buttons = list(
                list(
                    extend = "csv",
                    filename = filename,
                    exportOptions = list(columns = ":not(.rownames)")
                ),
                list(
                    extend = "excel",
                    filename = filename,
                    exportOptions = list(columns = ":not(.rownames)"),
                    title = ""
                )
            ),
            columnDefs = list(
                list(
                    targets = 0,
                    className = "rownames"
                )
            ),
            dom = "Bfrtip"
        )
    }
    return(do.call(DT::datatable, args))
}

```

# Data

Load the following data for the City of Toronto:

* boundary
* centrelines
* all collisions
* verified bikeways

All collisions data was provided by David McElroy <David.McElroy@toronto.ca> from the City of Toronto on November 7, 2024.

Verified bikeways data originally from Konrad Samsel <konrad.samsel@mail.utoronto.ca> and later modified by Richard Wen <richard.wen@utoronto.ca> on October 27, 2024.

```{r}

# Load boundaries
bounds_raw <- read_sf("../../data/toronto-boundary-2019-07-23/citygcs_regional_mun_wgs84.shp")

# Load toronto centrelines data
ctl_raw <- read_sf("../../data/toronto-centrelines-2024-12-06.geojson")

# Load toronto bikeways data
bike_raw <- read_sf("../../data/toronto-bikeways-2024-10-27.geojson")

# Load all toronto collisions from 2022 to 2024
colli_raw <- read_sf(
	"../../tmp/i0327_collisionsrep_acc_export.csv",
	options = c(
		"X_POSSIBLE_NAMES=LONGITUDE",
		"Y_POSSIBLE_NAMES=LATITUDE"
	),
	crs = 4326
)
```

# Cleaning

For the collisions:

1. Crop all collision points to the boundaries of the City of Toronto
2. Convert the accident date `ACCDATE` to `date` type
3. Add a column to separate the collisions data for Killed or Seriously Injured (KSI) and non-KSI individuals
4. Add columns to identify drivers (and passengers), pedestrians, cyclists (and cyclist passengers), and other road users

For the verified bikeways:

1. Filter for Bloor Street, University Avenue, and Yonge Street
2. Calculate the final type and year for each verified bikeway, where improvements (when the same type occurs between upgrades) are not considered an upgrade
3. Filter for cycle tracks only based on the final type

For the centrelines, extract target streets Bloor Street, Danforth Street/Avenue, University Avenue, and Yonge Street, and merge all segments for each target street.

```{r}

# Reproj city bounds to 4326
bounds <- bounds_raw %>% st_transform(4326)

# Crop colli to toronto bounds and convert date type
colli <- colli_raw %>%
	st_intersection(bounds) %>%
	mutate(colli_date = as_date(ACCDATE))

# Add a columns for ksi and road users
ksi_codes <- c("3", "4")
colli <- colli %>%
	mutate(
		ksi = if_else(INJURY %in% ksi_codes, "ksi", "non_ksi"), # ksi col
		user = case_when( # road user col
			INVTYPE %in% c("01", "02") ~ "driver",
			INVTYPE == "03" ~ "pedestrian",
			INVTYPE %in% c("04", "05") ~ "cyclist",
			.default = "other"
		)
	)

# Get cycle tracks only after all upgrades
bike <- bike_raw %>%
	mutate( # create col for target streets
		target_street = case_when(
			str_starts(street, "Bloor") ~
				"Bloor Street",
			str_starts(street, "University") ~
				"University Avenue",
			str_starts(street, "Yonge") ~
				"Yonge Street",
			str_starts(street, "Danforth") ~
				"Danforth Street/Avenue",
			.default = NA
		)
	) %>%
	filter(!is.na(target_street)) %>%
	mutate(
		final_type = case_when( # col for final type without improvements
			!is.na(verify_upgrade2_year) &
			verify_upgrade2_type != verify_upgrade1_type
				~ verify_upgrade2_type,
			!is.na(verify_upgrade1_year) &
			verify_upgrade1_type != verify_install_type
				~ verify_upgrade1_type,
			!is.na(verify_install_year)
				~ verify_install_type,
			.default = NA
		),
		final_type = case_when( # remap infra types to actual names
			final_type %in% c("PL", "BUF") ~ "Painted Lane",
			final_type == "PBL" ~ "Cycle Track",
			.default = NA
		)
	) %>%
	mutate( # col for final year without improvements
		final_year = case_when(
			!is.na(verify_upgrade2_year) &
			verify_upgrade2_type != verify_upgrade1_type
				~ verify_upgrade2_year,
			!is.na(verify_upgrade1_year) &
			verify_upgrade1_type != verify_install_type
				~ verify_upgrade1_year,
			!is.na(verify_install_year)
				~ verify_install_year,
			.default = NA
		),
		history = glue("
			{verify_install_type},{verify_install_year} -> 
			{verify_upgrade1_type},{verify_upgrade1_year} -> 
			{verify_upgrade2_type},{verify_upgrade2_year}
		")
	) %>%
	filter( # filter for cycle tracks only
		final_type == "Cycle Track"
	)

# Remove non pl and ct types
bike <- bike %>%
	mutate(
		verify_install_type = if_else(
			verify_install_type %in% c("PL", "BUF", "PBL"),
			verify_install_type,
			NA
		),
		verify_upgrade1_type = if_else(
			verify_upgrade1_type %in% c("PL", "BUF", "PBL"),
			verify_upgrade1_type,
			NA
		),
		verify_upgrade2_type = if_else(
			verify_upgrade2_type %in% c("PL", "BUF", "PBL"),
			verify_upgrade2_type,
			NA
		)
	)

# Add history to bike lanes without improvements
bike <- bike %>%
	mutate( # remove improvements
		verify_upgrade1_year = if_else(
			!is.na(verify_upgrade1_type) &
			!is.na(verify_install_type) &
			verify_install_type == verify_upgrade1_type,
			NA,
			verify_upgrade1_year
		),
		verify_upgrade1_type = if_else(
			!is.na(verify_upgrade1_type) &
			!is.na(verify_install_type) &
			verify_install_type == verify_upgrade1_type,
			NA,
			verify_upgrade1_type
		),
		verify_upgrade2_year = if_else(
			!is.na(verify_upgrade2_type) &
			!is.na(verify_upgrade1_type) &
			verify_upgrade2_type == verify_upgrade1_type,
			NA,
			verify_upgrade2_year
		),
		verify_upgrade2_type = if_else(
			!is.na(verify_upgrade2_type) &
			!is.na(verify_upgrade1_type) &
			verify_upgrade2_type == verify_upgrade1_type,
			NA,
			verify_upgrade2_type
		)
	) %>%
	mutate(
        history = glue(
            "{verify_install_type},{verify_install_year}",
            " -> {verify_upgrade1_type},{verify_upgrade1_year}",
            " -> {verify_upgrade2_type},{verify_upgrade2_year}",
        ) %>%
            str_remove_all(" -> NA,NA|NA,NA -> |NA,NA")
    )

# Filter centrelines for Bloor, University and Yonge
streets <- ctl_raw %>%
	filter( # filter for streets only
		FEATURE_CODE_DESC %in% c(
			"Major Arterial",
		    "Major Arterial Ramp",
		    "Minor Arterial",
		    "Minor Arterial Ramp",
		    "Collector",
		    "Access Road",
		    "Other",
		    "Laneway",
		    "Local"
		)
	) %>%
	mutate( # create col for streets bloor, uni, and yonge
		target_street = case_when(
			str_starts(
				LINEAR_NAME_FULL_LEGAL,
				"Bloor Street"
			) ~ "Bloor Street",
			str_starts(
				LINEAR_NAME_FULL_LEGAL,
				"University Avenue"
			) ~ "University Avenue",
			str_starts(
				LINEAR_NAME_FULL_LEGAL,
				"Yonge Street"
			) ~ "Yonge Street",
			str_starts( # Prince Edward Viaduct
				LINEAR_NAME_FULL_LEGAL,
				"Danforth Avenue|Danforth Street"
			) ~ "Danforth Street/Avenue",
			.default = NA
		)
	) %>%
	filter(!is.na(target_street)) %>%
	group_by(target_street) %>% # merge geoms on streets
	summarize(geometry = st_union(geometry))

```

# Processing

Find all collision points within 25 meters of the verified bikeways on Yonge, Bloor and University.

```{r}

# Get row indices of nearest bikeway to each collision
near_idx <- colli %>% st_nearest_feature(bike)

# Calc distances to nearest bikeway for each collision
colli_bike <- colli %>%
	mutate( # calc dist to nearest bikeway for each ksi
		`near_bike_meters` = st_distance(
			geometry,
			bike[near_idx, ],
			by_element = T
		) %>% as.numeric
	)

# Get df version of bike
bike_df <- bike %>% as_tibble %>% select(-geometry)

# Add bike columns to collisions
colli_bike <- colli_bike %>%
	mutate( # add ids for bike
		bike_id = bike_df[near_idx, ]$id
	) %>%
	left_join( # add bike cols to colli
		bike_df,
		by = join_by(bike_id == id)
	)

# Filter for collisions within 25 meters of the bikeways
colli_bike <- colli_bike %>%
	filter(near_bike_meters <= 25)
```

Then, count the injuries by the collision quarter, KSI/Non-KSI, and road user.

Also add installs/upgrades of painted lane and cycle track infrastructure, if they are present in the collision quarter.

```{r}

# Count by injuries quarter
colli_counts <- colli_bike %>%
	as_tibble %>%
	select(-geometry) %>%
	mutate( # add time units
		year = year(colli_date),
		quarter = quarter(colli_date),
	) %>%
	rename(
		orig_street = street,
		street = target_street
	) %>%
	group_by(year, quarter, street, user, ksi) %>%
	count %>%
	arrange(year, quarter, street, user, ksi) %>%
	ungroup

# Add counts for Bloor and Danforth together
colli_counts <- colli_counts %>%
	add_row(
		colli_counts %>%
			filter(street %in% c(
				"Bloor Street",
				"Danforth Street/Avenue")
			) %>%
			mutate(street = "Bloor & Danforth") %>%
			group_by(year, quarter, street, user, ksi) %>%
			summarize(n = sum(n, na.rm = T))
	)

# Add bikeways for bloor and danforth together
bike_proc <- bike %>%
	add_row(
		bike %>%
			filter(target_street %in% c(
				"Bloor Street",
				"Danforth Street/Avenue"
			)) %>%
			mutate(target_street = "Bloor & Danforth")
	)

# Ensure all combinations are available
min_year <- min(year(colli_bike$colli_date), na.rm = T)
max_year <- max(year(colli_bike$colli_date), na.rm = T)
colli_counts <- expand_grid(
	year = min_year:max_year,
	quarter = 1:4,
	street = unique(colli_counts$street),
	user = unique(colli_counts$user),
	ksi = unique(colli_counts$ksi)
) %>%
	left_join(
		colli_counts,
		by = c(
			"year",
			"quarter",
			"street",
			"user",
			"ksi"
		)
	)

# Calc cycle track events with segment length and counts
bike_events <- data.frame(
    year = c(
    	bike_proc$verify_install_year,
    	bike_proc$verify_upgrade1_year,
    	bike_proc$verify_upgrade2_year
    ),
    add_type = c(
    	bike_proc$verify_install_type,
    	bike_proc$verify_upgrade1_type,
    	bike_proc$verify_upgrade2_type
    ),
    street = rep(bike_proc$target_street, 3),
    geometry = rep(bike_proc$geometry, 3)
) %>%
    filter(!is.na(year) & !is.na(add_type)) %>%
    st_as_sf %>%
	group_by(street, year, add_type) %>%
	summarize(
		add_len_km = as.numeric(sum(st_length(geometry))) / 1000,
		add_segments = n()
	) %>%
	as_tibble %>%
	select(-geometry) %>%
	mutate(
		add_year = year
	) %>%
	arrange(street, year) %>%
	group_by(street) %>%
	mutate(
		add_segments = cumsum(add_segments)
	) %>%
	ungroup

# Fill years in between infra events
bike_events_fill <- bike_events %>%
    group_by(street) %>%
    group_map(~{
        expand.grid(year = min(.x$year):max(.x$year)) %>%
            left_join(.x, by = "year") %>%
            fill(everything())
    }, .keep = T) %>%
	bind_rows

# Add bike events to the counts
colli_counts <- colli_counts %>%
	left_join(
		bike_events_fill %>%
			select(
				year,
				street,
				add_segments,
				add_type,
				add_year,
				add_len_km
			),
		by = c("year", "street")
	) %>%
	arrange(street, year, quarter, add_type, user, ksi)

# Add post col to define if year is post first install of a cycle track
colli_counts <- colli_counts %>%
	group_by(street) %>%
	group_map(~{
		
		# Set out df
		out <- .x
		
		# Calculate first ct and pl if exists
		pl_ymin <- colli_counts %>%
			filter(add_type %in% c("PL", "BUF")) %>%
			pull(year)
		ct_ymin <- colli_counts %>%
			filter(add_type == "PBL") %>%
			pull(year)
		
		# Post pl col
		if (length(pl_ymin) > 0) {
			out <- out %>%
				mutate(
					post_1st_pl = if_else(
						.x$add_type %in% c("PL", "BUF") &
						.x$year >= min(pl_ymin, na.rm = T),
						T,
						F
					)
				)
		}
		
		# Post first ct col
		if (length(ct_ymin) > 0) {
			out <- out %>%
				mutate(
					post_1st_ct = if_else(
						.x$add_type == "PBL" &
						.x$year >= min(ct_ymin, na.rm = T),
						T,
						F
					)
				)
		}
		
		# Return df with post cols
		return(out)
		
	}, .keep = T) %>%
	bind_rows

```

# Results {.tabset}

The results contain:

1. Data in wide format with collision counts divided by road user and KSI/Non-KSI for each street by year
2. A plot showing when the data in 1. with when the cycle tracks were implemented for each street
3. A map showing the locations of the cycle tracks for each street and a heatmap of the collision density

## Data {.tabset .tabset-pills}

### All

The resulting data consists of the following columns:

* `year` the year of the collisions
* `quarter`: the quarter of the collisions
* `street`: the street, one of Yonge Street, University Avenue, or Bloor Street
* `add_year`: the year that the infrastructure was added
* `add_type`: the type of infrastructure added
* `add_len_km`: the length of the infrastructure added
* `add_segments`: the number of segments of the infrastructure added
* `post_1st_ct`: whether the year is on or after the first cycle track implementation
* `post_1st_pl`: whether the year is on or after the first painted or buffered lane implementation
* `ksi`: the number of Killed or Seriously Injured (KSI) collisions
* `non_ksi`: the number of non-KSI collisions
* `<USER>_ksi`: the number of KSI individuals for a road user group indicated by `<USER>`
* `<USER>_non_ksi`: the number of non-KSI individuals for a road user group indicated by `<USER>`

```{r fig.height = 8, fig.width = 8}

# Create output data
out <- colli_counts %>%
	mutate(
		group = glue("{user}_{ksi}")
	) %>%
	pivot_wider(
		values_from = n,
		names_from = group
	) %>%
	select(-user, -ksi) %>%
	group_by(year, quarter, street, add_type) %>%
	summarize(
		across(
			ends_with("_ksi"),
			~ sum(., na.rm = T)
		),
		across(
			starts_with(c("add_", "post_")),
			~ paste0(unique(.), collapse = ",")
		),
		add_segments = as.numeric(unique(add_segments))
	) %>%
	ungroup %>%
	mutate( # calc total ksi
		ksi = select(., !ends_with ("_non_ksi") & ends_with("_ksi")) %>%
			rowSums(na.rm = T),
		non_ksi = select(., ends_with("_non_ksi")) %>%
			rowSums(na.rm = T)
	) %>%
	mutate( # turn labels into full desc
		add_type = case_when(
			add_type %in% c("PL", "BUF") ~ "Painted Lane",
			add_type == "PBL" ~ "Cycle Track",
			.default = "None"
		)
	) %>%
	select(order(colnames(.))) %>%
	select(
		year,
		quarter,
		street,
		add_year,
		add_type,
		add_len_km,
		add_segments,
		starts_with("post_"),
		ksi,
		non_ksi,
		everything()
	) %>%
	arrange(street, year, quarter, add_type)

# Show data table
datatable(
	out,
	filename = glue("toronto-collisions-bloorunidanyonge-{today()}")
)
```

### Rates

The rates data consists of quarterly rates by road user per year.

* `year` the year of the collisions
* `street`: the street, one of Yonge Street, University Avenue, or Bloor Street
* `add_type`: the type of infrastructure added
* `<USER>_ksi_per_quarter`: the number of KSI individuals per quarter for a road user group indicated by `<USER>`
* `<USER>_non_ksi_per_quarter`: the number of non-KSI collisions per quarter for a road user group indicated by `<USER>`

```{r}

# Calc rates for output
out_rates <- out %>%
	filter(add_type != "None") %>%
	group_by(street, year, add_type) %>%
	summarize(across(
		ends_with("_ksi"),
		~ (sum(.) / unique(add_segments)) / 4,
		.names = "{.col}_per_quarter"
	))

# Show data table
datatable(
	out_rates,
	filename = glue("toronto-collisions-bloorunidanyonge-rates-{today()}")
)

```

## Plot {.tabset .tabset-pills}

These plots show the number of KSI collisions by road user for cycle tracks on Bloor Streeet, University Avenue, and Yonge Street. The dark gray dotted vertical lines show which year a cycle track is added to the street along with the amount of cycle track kilometers added.

```{r}

plot_bike <- bike_events %>%
	mutate(
		len_km_label = glue("+{round(add_len_km, 2)} km"),
		len_km_legend = case_when(
			add_type %in% c("PL", "BUF") ~ "Painted Lane Added",
			add_type %in% "PBL" ~ "Cycle Track Added",
			.default = NA
		),
		len_km_date = as_date(glue("{add_year}-01-01")),
		quarter_date = if_else(
			year >= min(colli_counts$year) & year <= max(colli_counts$year),
			glue("{year}-01-01") %>% as_date,
			NA
		)
	)

# Calc label position for ct events
plot_bike_y <- colli_counts %>%
	group_by(user) %>%
	summarize(
		len_km_label_y = max(n, na.rm = T) + 0.3 * (max(n, na.rm = T))
	)

# Prep plot data
plot_data <- colli_counts %>%
	rowwise %>%
	mutate(
		quarter_date = glue("{year}-{quarter * 3}-01") %>% as_date
	) %>%
	mutate(
		user = str_to_title(user),
		ksi = if_else(ksi == "non_ksi", "Non-KSI", "KSI")
	) %>%
	filter(user != "Other")

# Calc total cycle track len for each street
bike_len <- bike_proc %>%
	group_by(target_street) %>%
	summarize(
		final_len_km = sum(st_length(geometry), na.rm = T) / 1000 %>%
			as.numeric
	) %>%
	as_tibble %>%
	select(-geometry) %>%
	rename(street = target_street)

# Add total len for each street as labels
plot_data <- plot_data %>%
	left_join(bike_len, by = "street") %>%
	mutate(
		street = glue(
			"{street} ({round(final_len_km, 2)} km)"
		)
	)

# Add cumulative sums for ct len
plot_data <- plot_data %>%
    group_by(street, user, ksi) %>%
    mutate(
        ct_len_km_csum = if_else(
            add_type == "PBL" & year == add_year & quarter == 1,
            add_len_km,
            0
        ) %>% replace_na(0),
        ct_len_km_csum = cumsum(ct_len_km_csum)
    )
```

### Non-KSI

```{r toronto-collisions-bloorunidanyonge-nonksi, fig.width = 22, fig.height = 9, message = F, warning = F}

# Generate plot for non ksi
ggplot(
	plot_data %>%
		filter(ksi == "Non-KSI" & !is.na(n)),
	aes(x = quarter_date, y = n)
) +
	geom_line(
		aes(color = ct_len_km_csum)
	) +
	#geom_point(show.legend = F) +
	facet_grid(
		user ~ street,
		scales = "free",
		switch = "y"
	) +
	geom_text(
		aes(label = n),
		size = 2.25,
		angle = 90,
		hjust = -2
	) +
	scale_color_gradient(
		low = "lightgray",
		high = "black",
		name = "Cycle Track (km)",
		breaks = c(0, 2, 4, 6, 8, 10, 12, 15)
	) +
	theme_minimal() +
	scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
	scale_y_continuous(expand = expansion(mult = c(0.1, 0.3))) +
	labs(
		x = "Year",
		y = "Non-KSI Individuals"
	) +
	theme(
		axis.text.x = element_text(size = 8),
		legend.position = "top"
	)

```

### KSI

```{r toronto-collisions-bloorunidanyonge-ksi, fig.width = 22, fig.height = 9, message = F, warning = F}

# Generate plot for non ksi
ggplot(
	plot_data %>%
		filter(ksi == "KSI" & !is.na(n)),
	aes(x = quarter_date, y = n)
) +
	geom_line(
		aes(color = ct_len_km_csum)
	) +
	#geom_point(show.legend = F) +
	facet_grid(
		user ~ street,
		scales = "free",
		switch = "y"
	) +
	geom_text(
		aes(label = n),
		size = 2.25,
		angle = 90,
		hjust = -2
	) +
	scale_color_gradient(
		low = "lightgray",
		high = "black",
		name = "Cycle Track (km)",
		breaks = c(0, 2, 4, 6, 8, 10, 12, 15)
	) +
	theme_minimal() +
	scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
	scale_y_continuous(expand = expansion(mult = c(0.1, 0.3))) +
	labs(
		x = "Year",
		y = "KSI Individuals"
	) +
	theme(
		axis.text.x = element_text(size = 8),
		legend.position = "top"
	)

```

## Map

This map shows the location of cycle tracks on Bloor Streeet, University Avenue, and Yonge Street, along with the collision density within 25 meters of each cycle track.

```{r}

# Visualize results of target streets and cycle tracks
tmap_mode("view")
tmap_leaflet(
	tm_shape(bounds) +
		tm_polygons(alpha = 0, popup.vars = F, id = "") +
		tm_shape(streets) +
		tm_lines(col = "#1d1d1d", popup.vars = T) +
		tm_text("target_street", size = 1) +
		tm_shape(
			bike %>%
				select(-ends_with("_comment")) %>%
				filter(target_street != "Bloor & Danforth")
		) +
		tm_lines(col = "red", lwd = 2, popup.vars = T)
	) %>%
	addFullscreenControl%>%
	addHeatmap(
		data = colli_bike %>%
			distinct(ACCNB, .keep_all = TRUE),
		lat = ~LATITUDE,
		lng = ~LONGITUDE,
		radius = 8
	) %>%
	addLegend(
		position = "topright",
		colors = c("red", "#1d1d1d"),
		labels = c("Cycle Track", "Street")
	) %>%
	addLegend(
		position = "topright",
		colors = colorNumeric(
			c("blue", "green", "yellow", "orange"),
			domain = NULL
		)(seq(1, 100, length.out = 5)),
		values = c(1, 10),
		labels = c("Low", "", "", "", "High"),
		title = "Collision<br/>Density"
	)

```
