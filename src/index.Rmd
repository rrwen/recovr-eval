---
title: "Cycling Interventions Evaluation"
subtitle: "R Code"
author:
- "Richard Wen richard.wen@utoronto.ca"
- "Brice Batomen brice.kuimi@utoronto.ca"
- "Linda Rothman linda.rothman@torontomu.ca"
- "Andrew Howard andrew.howard@sickkids.ca"
date: "`r format(Sys.time(), '%B %d, %Y')`"
knit: |
    (function(input_rmd, ...) {
    rmarkdown::render(
        input_rmd,
        rmarkdown::html_document(
            toc = TRUE,
            toc_float = TRUE,
            highlight = "zenburn",
            code_folding = "hide",
            df_print = "paged",
            self_contained = FALSE
        ),
        output_dir = "../docs",
        output_file = "index", ...)
    })
---

```{r include = FALSE, echo = FALSE}
knitr::opts_chunk$set(
	warning = FALSE,
	message = FALSE
)
```

# Installation

1.  Install [R](https://www.r-project.org/)
2.  Install [RTools](https://cran.r-project.org/) if you are on Windows
3.  Install [RStudio](https://posit.co/download/rstudio-desktop/)

For more details, see [Software and Package Versions](#software-and-package-versions).

# Running This Code

1.  Ensure the installation steps above are completed
2.  Download a zip of the code and data [here](https://github.com/rrwen/recovr-eval/archive/refs/heads/main.zip) and unzip it
    - Code Repository: [github.com/rrwen/recovr-eval](https://github.com/rrwen/recovr-eval)
3.  In RStudio, open the [src/src.Rproj](https://github.com/rrwen/recovr-eval/blob/main/src/src.Rproj) file
4.  Then, open the [src/index.Rmd](https://github.com/rrwen/recovr-eval/blob/main/src/index.Rmd) file
5.  In RStudio:
    - Run all code: Click the `Run` drop down (top right of the code pane) and click `Run All`
    - Generate HTML version: Click `knit` (top left of code pane) and a file will be generated in `docs/index.html`

# Libraries

Install R packages if needed.

```{r, results = FALSE}

# Required packages
required_packages <- c(
	"rmarkdown",
	"bookdown",
	"knitr",
	"tidyverse",
	"purrr",
	"glue",
	"lubridate",
	"scales",
	"patchwork",
	"DiagrammeR",
	"DiagrammeRsvg",
	"webshot2",
	"magick",
	"rsvg",
	"sf",
	"tmap",
	"ggspatial",
	"prettymapr",
	"units",
	"boot"
)

# Try to install packages if not installed
default_options <- options()
tryCatch(
	{
		# Disable interactivity
		options(install.packages.compile.from.source = "always")
		
		# Install package if not installed
		for (package in required_packages) {
			is_package_installed <- require(package, character.only = TRUE)
			if (!is_package_installed) {
				cat(paste0("Installing package: ", package, "\n"))
				install.packages(package)
			} else {
				cat(paste0("Package already installed: ", package, "\n"))
			}
		}
	},
	error = function(cond) {
		stop(cond)
	},
	finally = {
		options(default_options) # reset interactivity
	}
)
```

Load R libraries.

```{r}
library(boot)
library(DiagrammeR)
library(ggplot2)
library(ggspatial)
library(glue)
library(lubridate)
library(patchwork)
library(sf)
library(tidyverse)
library(tmap)
```

# Data

Read data from the `data` folder.

```{r}
ddesc <- read_csv("../data/data.csv")
ddesc
```

## Vancouver Bikeways {.tabset}

`r ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(notes)`

```{r}

# Read data
vancbike_raw <- read_sf("../data/vancouver-bikeways-2024-06-02.geojson")

# Get download date
vancbike_dldate <- ddesc %>% filter(
	file == "vancouver-bikeways-2024-06-02.geojson"
) %>% pull(download_date)
```

### Map

Only the first 1000 records are shown.

```{r}
tmap_mode("view")
tm_shape(vancbike_raw %>% head(1000)) +
    tm_lines(
    	col = "#336699",
    	border.col = "white",
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(vancbike_raw)`
* Rows: `r nrow(vancbike_raw)`

```{r}
vancbike_raw %>% as_tibble
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
#vancbike_ddict <- read_csv("../data/vancouver-bikeways-2024-06-02-datadict.csv")
#vancbike_ddict
```

### Details

```{r}
print(vancbike_raw)
```

### Files

The data files are available below:

- [vancouver-bikeways-2024-06-02.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/vancouver-bikeways-2024-06-02.geojson)
- [vancouver-bikeways-2024-06-02-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/vancouver-bikeways-2024-06-02-datadict.csv)

## Calgary Bikeways {.tabset}

`r ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(notes)`

```{r}

# Read data
calgbike_raw <- read_sf("../data/calgary-bikeways-2024-06-05.geojson")

# Get download date
calgbike_dldate <- ddesc %>% filter(
	file == "calgary-bikeways-2024-06-05.geojson"
) %>% pull(download_date)
```

### Map

Only the first 1000 records are shown.

```{r}
tmap_mode("view")
tm_shape(calgbike_raw %>% head(1000)) +
    tm_lines(
    	col = "#336699",
    	border.col = "white",
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(calgbike_raw)`
* Rows: `r nrow(calgbike_raw)`

```{r}
calgbike_raw %>% as_tibble
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
#calgbike_ddict <- read_csv("../data/calgary-bikeways-2024-06-05-datadict.csv")
#calgbike_ddict
```

### Details

```{r}
print(calgbike_raw)
```

### Files

The data files are available below:

- [calgary-bikeways-2024-06-05.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/calgary-bikeways-2024-06-05.geojson)
- [calgary-bikeways-2024-06-05-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/calgary-bikeways-2024-06-05-datadict.csv)

## Toronto Bikeways {.tabset}

`r ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(notes)`

```{r}

# Read data
toronbike_raw <- read_sf("../data/toronto-bikeways-2024-06-02.geojson")

# Get download date
toronbike_dldate <- ddesc %>% filter(
	file == "toronto-bikeways-2024-06-02.geojson"
) %>% pull(download_date)
```

### Map

Only the first 1000 records are shown.

```{r}
tmap_mode("view")
tm_shape(toronbike_raw %>% head(1000)) +
    tm_lines(
    	col = "#336699",
    	border.col = "white",
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(toronbike_raw)`
* Rows: `r nrow(toronbike_raw)`

```{r}
toronbike_raw %>% as_tibble
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
#toronbike_ddict <- read_csv("../data/toronto-bikeways-2024-06-02-datadict.csv")
#toronbike_ddict
```

### Details

```{r}
print(toronbike_raw)
```

### Files

The data files are available below:

- [toronto-bikeways-2024-06-02.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-bikeways-2024-06-02.geojson)
- [toronto-bikeways-2024-06-02-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-bikeways-2024-06-02-datadict.csv)


## Toronto KSI {.tabset}

`r ddesc %>% filter(file == "toronto-ksi-2024-06-01.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "toronto-ksi-2024-06-01.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "toronto-ksi-2024-06-01.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "toronto-ksi-2024-06-01.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "toronto-ksi-2024-06-01.geojson") %>% pull(notes)`

```{r}

# Read data
ksi_raw <- read_sf("../data/toronto-ksi-2024-06-01.geojson")

# Get download date
ksi_dldate <- ddesc %>% filter(
	file == "toronto-ksi-2024-06-01.geojson"
) %>% pull(download_date)
```

### Map

**Note**: Due to the large number of records, only the latest year of `r year(max(ksi_raw$DATE))` is displayed (n = `r ksi_raw %>% filter(year(DATE) == max(year(DATE))) %>% nrow`).

```{r}
tmap_mode("view")
tm_shape(ksi_raw %>% filter(year(DATE) == max(year(DATE)))) +
    tm_dots(
    	col = "ACCLASS",
    	clustering = TRUE,
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(ksi_raw)`
* Rows: `r nrow(ksi_raw)`

```{r}
ksi_raw %>% as_tibble()
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
ksi_ddict <- read_csv("../data/toronto-ksi-2024-06-01-datadict.csv")
ksi_ddict
```

### Details

```{r}
print(ksi_raw)
```

### Files

The data files are available below:

- [toronto-ksi-2024-06-01.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-ksi-2024-06-01.geojson)
- [toronto-ksi-2024-06-01-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-ksi-2024-06-01-datadict.csv)

# Cleaning

## Determine Temporal Scale

```{r}

parsed <- list()
msg <- list()
bikeways <-  list(
	Vancouver = vancbike_raw,
	Calgary = calgbike_raw,
	Toronto = toronbike_raw
)

for (city in names(bikeways)) {
	
	# Filter for verified bikeways only
	df <- bikeways[[city]] %>%
		filter(
			!is.na(verify_install_year) |
			!is.na(verify_upgrade1_year) |
			!is.na(verify_upgrade2_year)
		)
	
	# Filter out non verified
	if (city == "Vancouver") {
		df <- df %>%
			filter(is.na(no_verify_install_type))
	}
	
	# Try to parse install dates
	df <- df %>%
		as_tibble %>%
		mutate(
			clean_date = str_to_lower(
				str_replace_all(
					verify_install_date,
					"[^[:alnum:]]",
					" "
				)
			),
			parsed_date = ymd(clean_date) %>%
				coalesce(ydm(clean_date)) %>%
				coalesce(mdy(clean_date)) %>%
				coalesce(myd(clean_date)) %>%
				coalesce(dmy(clean_date)) %>%
				coalesce(dym(clean_date)),
			parsed_month = if_else(
				!str_starts(str_trim(clean_date), "pre") & is.na(parsed_date),
				yq(clean_date) %>%
				coalesce(ym(clean_date)) %>%
				coalesce(my(clean_date)),
				NA
			)
		) %>%
		rename(
			clean_install_date = clean_date,
			parsed_install_date = parsed_date,
			parsed_install_month = parsed_month
		)
	
	# Try to parse upgrade 1 dates
	df <- df %>%
		as_tibble %>%
		mutate(
			clean_date = str_to_lower(
				str_replace_all(
					verify_upgrade1_date,
					"[^[:alnum:]]",
					" "
				)
			),
			parsed_date = ymd(clean_date) %>%
				coalesce(ydm(clean_date)) %>%
				coalesce(mdy(clean_date)) %>%
				coalesce(myd(clean_date)) %>%
				coalesce(dmy(clean_date)) %>%
				coalesce(dym(clean_date)),
			parsed_month = if_else(
				!str_starts(str_trim(clean_date), "pre") & is.na(parsed_date),
				yq(clean_date) %>%
				coalesce(ym(clean_date)) %>%
				coalesce(my(clean_date)),
				NA
			)
		) %>%
		rename(
			clean_upgrade1_date = clean_date,
			parsed_upgrade1_date = parsed_date,
			parsed_upgrade1_month = parsed_month
		)
	
	# Try to parse upgrade 1 dates
	df <- df %>%
		as_tibble %>%
		mutate(
			clean_date = str_to_lower(
				str_replace_all(
					verify_upgrade2_date,
					"[^[:alnum:]]",
					" "
				)
			),
			parsed_date = ymd(clean_date) %>%
				coalesce(ydm(clean_date)) %>%
				coalesce(mdy(clean_date)) %>%
				coalesce(myd(clean_date)) %>%
				coalesce(dmy(clean_date)) %>%
				coalesce(dym(clean_date)),
			parsed_month = if_else(
				!str_starts(str_trim(clean_date), "pre") & is.na(parsed_date),
				yq(clean_date) %>%
				coalesce(ym(clean_date)) %>%
				coalesce(my(clean_date)),
				NA
			)
		) %>%
		rename(
			clean_upgrade2_date = clean_date,
			parsed_upgrade2_date = parsed_date,
			parsed_upgrade2_month = parsed_month
		)
	
	# Num of records with install or upgrade dates
	n_idates <- df %>% filter(!is.na(verify_install_date)) %>% nrow
	n_u1dates <- df %>% filter(!is.na(verify_upgrade1_date)) %>% nrow
	n_u2dates <- df %>% filter(!is.na(verify_upgrade2_date)) %>% nrow
	
	# Num of records with parsed dates and months
	n_pidates <- df %>% filter(!is.na(parsed_install_date)) %>% nrow
	n_pimonths <- df %>% filter(!is.na(parsed_install_month)) %>% nrow
	n_pu1dates <- df %>% filter(!is.na(parsed_upgrade1_date)) %>% nrow
	n_pu1months <- df %>% filter(!is.na(parsed_upgrade1_month)) %>% nrow
	n_pu2dates <- df %>% filter(!is.na(parsed_upgrade2_date)) %>% nrow
	n_pu2months <- df %>% filter(!is.na(parsed_upgrade2_month)) %>% nrow
	
	# Perc of records with install or upgrade dates
	perc_idates <- round(n_idates / nrow(df) * 100, 2)
	perc_u1dates <- round(n_u1dates / nrow(df) * 100, 2)
	perc_u2dates <- round(n_u2dates / nrow(df) * 100, 2)
	
	# Perc of records with parsed dates and months
	perc_pidates <- round(n_pidates / nrow(df) * 100, 2)
	perc_pimonths <- round(n_pimonths / nrow(df) * 100, 2)
	perc_pu1dates <- round(n_pu1dates / nrow(df) * 100, 2)
	perc_pu1months <- round(n_pu1months / nrow(df) * 100, 2)
	perc_pu2dates <- round(n_pu2dates / nrow(df) * 100, 2)
	perc_pu2months <- round(n_pu2months / nrow(df) * 100, 2)
	
	# Add to list
	msg[[city]] <- glue(
		"\n\n**Verified {city} Bikeways (n = {df %>% nrow}, 100%)**\n",
		"\n* Install Dates: {n_idates} ({perc_idates}%)",
		"\n\t* Parsable Dates: {n_pidates} ({perc_pidates}%)",
		"\n \t* Parsable Months: {n_pimonths} ({perc_pimonths}%)",
		"\n* Upgrade 1 Dates: {n_u1dates} ({perc_u1dates}%)",
		"\n\t* Parsable Dates: {n_pu1dates} ({perc_pu1dates}%)",
		"\n\t* Parsable Months: {n_pu1months} ({perc_pu1months}%)",
		"\n* Upgrade 2 Dates: {n_u2dates} ({perc_u2dates}%)",
		"\n\t* Parsable Dates: {n_pu2dates} ({perc_pu2dates}%)",
		"\n\t* Parsable Months: {n_pu2months} ({perc_pu2months}%)\n\n"
	)
	
	df <- df %>% filter(
		!is.na(verify_install_date) |
		!is.na(verify_upgrade1_date) |
		!is.na(verify_upgrade2_date)
	)
	parsed[[city]] <- data.frame(
		orig_date = c(df$verify_install_date, df$verify_upgrade1_date, df$verify_upgrade2_date),
		clean_date = c(df$clean_install_date, df$clean_upgrade1_date, df$clean_upgrade2_date),
		parsed_date = c(df$parsed_install_date, df$parsed_upgrade1_date, df$parsed_upgrade2_date),
		parsed_month = c(df$parsed_install_month, df$parsed_upgrade1_month, df$parsed_upgrade2_month)
	)
	
	parsed[[city]] <- parsed[[city]] %>%
		group_by(orig_date) %>%
		count() %>%
		ungroup %>%
		left_join(
			 parsed[[city]] %>%
				distinct(orig_date, .keep_all = T),
			 by = "orig_date"
		) %>%
		arrange(desc(n)) %>%
		filter(!is.na(orig_date))
}
```

```{r results = "asis"}
cat(msg[["Vancouver"]])
parsed[["Vancouver"]]
```

```{r results = "asis"}
cat(msg[["Calgary"]])
parsed[["Calgary"]]
```

```{r results = "asis"}
cat(msg[["Toronto"]])
parsed[["Toronto"]]
```
