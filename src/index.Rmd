---
title: "Cycling Interventions Evaluation"
subtitle: "R Code"
author:
- "Richard Wen richard.wen@utoronto.ca"
- "Brice Batomen brice.kuimi@utoronto.ca"
- "Linda Rothman linda.rothman@torontomu.ca"
- "Andrew Howard andrew.howard@sickkids.ca"
date: "`r format(Sys.time(), '%B %d, %Y')`"
knit: |
    (function(input_rmd, ...) {
    rmarkdown::render(
        input_rmd,
        rmarkdown::html_document(
            toc = TRUE,
            toc_float = TRUE,
            highlight = "zenburn",
            code_folding = "hide",
            df_print = "paged",
            self_contained = FALSE
        ),
        output_dir = "../docs",
        output_file = "index", ...)
    })
---

```{r include = FALSE, echo = FALSE}
knitr::opts_chunk$set(
	warning = FALSE,
	message = FALSE
)
```

# Installation

1.  Install [R](https://www.r-project.org/)
2.  Install [RTools](https://cran.r-project.org/) if you are on Windows
3.  Install [RStudio](https://posit.co/download/rstudio-desktop/)

For more details, see [Software and Package Versions](#software-and-package-versions).

# Running This Code

1.  Ensure the installation steps above are completed
2.  Download a zip of the code and data [here](https://github.com/rrwen/recovr-eval/archive/refs/heads/main.zip) and unzip it
    - Code Repository: [github.com/rrwen/recovr-eval](https://github.com/rrwen/recovr-eval)
3.  In RStudio, open the [src/src.Rproj](https://github.com/rrwen/recovr-eval/blob/main/src/src.Rproj) file
4.  Then, open the [src/index.Rmd](https://github.com/rrwen/recovr-eval/blob/main/src/index.Rmd) file
5.  In RStudio:
    - Run all code: Click the `Run` drop down (top right of the code pane) and click `Run All`
    - Generate HTML version: Click `knit` (top left of code pane) and a file will be generated in `docs/index.html`

# Libraries

Install R packages if needed.

```{r, results = FALSE}

# Required packages
required_packages <- c(
	"rmarkdown",
	"bookdown",
	"knitr",
	"tidyverse",
	"purrr",
	"glue",
	"lubridate",
	"scales",
	"patchwork",
	"DiagrammeR",
	"DiagrammeRsvg",
	"webshot2",
	"magick",
	"rsvg",
	"sf",
	"tmap",
	"ggspatial",
	"prettymapr",
	"units",
	"leaflet",
	"leaflet.extras",
	"igraph",
	"ggrepel"
)

# Try to install packages if not installed
default_options <- options()
tryCatch(
	{
		# Disable interactivity
		options(install.packages.compile.from.source = "always")
		
		# Install package if not installed
		for (package in required_packages) {
			is_package_installed <- require(package, character.only = TRUE)
			if (!is_package_installed) {
				cat(paste0("Installing package: ", package, "\n"))
				install.packages(package)
			} else {
				cat(paste0("Package already installed: ", package, "\n"))
			}
		}
	},
	error = function(cond) {
		stop(cond)
	},
	finally = {
		options(default_options) # reset interactivity
	}
)
```

Load R libraries.

```{r}
library(DiagrammeR)
library(ggplot2)
library(ggspatial)
library(glue)
library(igraph)
library(leaflet)
library(leaflet.extras)
library(lubridate)
library(patchwork)
library(sf)
library(tidyverse)
library(tmap)
```

# Data

Read data from the `data` folder.

```{r}
ddesc <- read_csv("../data/data.csv")
ddesc
```

## Vancouver Bikeways {.tabset}

`r ddesc %>% filter(file == "vancouver-bikeways-2024-10-01.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "vancouver-bikeways-2024-10-01.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "vancouver-bikeways-2024-10-01.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "vancouver-bikeways-2024-10-01.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "vancouver-bikeways-2024-10-01.geojson") %>% pull(notes)`

```{r}

# Read data
vancbike_raw <- read_sf("../data/vancouver-bikeways-2024-10-01.geojson")

# Get download date
vancbike_dldate <- ddesc %>% filter(
	file == "vancouver-bikeways-2024-10-01.geojson"
) %>% pull(download_date)
```

### Map

Only the first 1000 records are shown.

```{r}
tmap_mode("view")
tm_shape(vancbike_raw %>% head(1000)) +
    tm_lines(
    	col = "#336699",
    	border.col = "white",
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(vancbike_raw)`
* Rows: `r nrow(vancbike_raw)`

```{r}
vancbike_raw %>% as_tibble
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
vancbike_ddict <- read_csv("../data/vancouver-bikeways-2024-10-01-datadict.csv")
vancbike_ddict
```

### Details

```{r}
print(vancbike_raw)
```

### Files

The data files are available below:

- [vancouver-bikeways-2024-10-01.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/vancouver-bikeways-2024-10-01.geojson)
- [vancouver-bikeways-2024-10-01-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/vancouver-bikeways-2024-10-01-datadict.csv)

## Calgary Bikeways {.tabset}

`r ddesc %>% filter(file == "calgary-bikeways-2024-10-27.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "calgary-bikeways-2024-10-27.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "calgary-bikeways-2024-10-27.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "calgary-bikeways-2024-10-27.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "calgary-bikeways-2024-10-27.geojson") %>% pull(notes)`

```{r}

# Read data
calgbike_raw <- read_sf("../data/calgary-bikeways-2024-10-27.geojson")

# Get download date
calgbike_dldate <- ddesc %>% filter(
	file == "calgary-bikeways-2024-10-27.geojson"
) %>% pull(download_date)
```

### Map

Only the first 1000 records are shown.

```{r}
tmap_mode("view")
tm_shape(calgbike_raw %>% head(1000)) +
    tm_lines(
    	col = "#336699",
    	border.col = "white",
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(calgbike_raw)`
* Rows: `r nrow(calgbike_raw)`

```{r}
calgbike_raw %>% as_tibble
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
calgbike_ddict <- read_csv("../data/calgary-bikeways-2024-10-27-datadict.csv")
calgbike_ddict
```

### Details

```{r}
print(calgbike_raw)
```

### Files

The data files are available below:

- [calgary-bikeways-2024-10-27.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/calgary-bikeways-2024-10-27.geojson)
- [calgary-bikeways-2024-10-27-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/calgary-bikeways-2024-10-27-datadict.csv)

## Toronto Bikeways {.tabset}

`r ddesc %>% filter(file == "toronto-bikeways-2024-10-27.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "toronto-bikeways-2024-10-27.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "toronto-bikeways-2024-10-27.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "toronto-bikeways-2024-10-27.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "toronto-bikeways-2024-10-27.geojson") %>% pull(notes)`

```{r}

# Read data
toronbike_raw <- read_sf("../data/toronto-bikeways-2024-10-27.geojson")

# Get download date
toronbike_dldate <- ddesc %>% filter(
	file == "toronto-bikeways-2024-10-27.geojson"
) %>% pull(download_date)

```

### Map

Only the first 1000 records are shown.

```{r}
tmap_mode("view")
tm_shape(toronbike_raw %>% head(1000)) +
    tm_lines(
    	col = "#336699",
    	border.col = "white",
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(toronbike_raw)`
* Rows: `r nrow(toronbike_raw)`

```{r}
toronbike_raw %>% as_tibble
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
toronbike_ddict <- read_csv("../data/toronto-bikeways-2024-10-27-datadict.csv")
toronbike_ddict
```

### Details

```{r}
print(toronbike_raw)
```

### Files

The data files are available below:

- [toronto-bikeways-2024-10-27.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-bikeways-2024-10-27.geojson)
- [toronto-bikeways-2024-10-27-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-bikeways-2024-10-27-datadict.csv)

## Verified Dates {.tabset}

`r ddesc %>% filter(file == "verify-dates-2024-06-12.csv") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "verify-dates-2024-06-12.csv") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "verify-dates-2024-06-12.csv") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "verify-dates-2024-06-12.csv") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "verify-dates-2024-06-12.csv") %>% pull(notes)`

```{r}

# Read data
vdates_raw <- read_csv("../data/verify-dates-2024-06-12.csv")

# Get download date
vdates_dldate <- ddesc %>% filter(
	file == "verify-dates-2024-06-12.csv"
) %>% pull(download_date)
```

### Data

* Columns: `r ncol(vdates_raw)`
* Rows: `r nrow(vdates_raw)`

```{r}
vdates_raw
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
vdates_ddict <- read_csv("../data/verify-dates-2024-06-12-datadict.csv")
vdates_ddict
```

### Files

The data files are available below:

- [verify-dates-2024-06-12.csv](https://github.com/rrwen/recovr-eval/blob/main/data/verify-dates-2024-06-12.csv)
- [verify-dates-2024-06-12-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/verify-dates-2024-06-12-datadict.csv)

## Toronto KSI {.tabset}

`r ddesc %>% filter(file == "toronto-ksi-2024-06-13.csv") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "toronto-ksi-2024-06-13.csv") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "toronto-ksi-2024-06-13.csv") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "toronto-ksi-2024-06-13.csv") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "toronto-ksi-2024-06-13.csv") %>% pull(notes)`

```{r}

# Read data
toronksi_raw <- read_sf(
	"../data/toronto-ksi-2024-06-13.csv",
	options = c(
		"X_POSSIBLE_NAMES=LONGITUDE",
		"Y_POSSIBLE_NAMES=LATITUDE"
	),
	crs = 4326
)

# Get download date
toronksi_dldate <- ddesc %>% filter(
	file == "toronto-ksi-2024-06-13.csv"
) %>% pull(download_date)
```

### Map

**Note**: Due to the large number of records, only the latest year of `r year(max(toronksi_raw$DATE))` is displayed (n = `r toronksi_raw %>% filter(year(DATE) == max(year(DATE))) %>% nrow`).

```{r}
tmap_mode("view")
tm_shape(toronksi_raw %>% filter(year(DATE) == max(year(DATE)))) +
    tm_dots(
    	col = "ACCLASS",
    	clustering = TRUE,
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(toronksi_raw)`
* Rows: `r nrow(toronksi_raw)`

```{r}
toronksi_raw %>% as_tibble()
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
ksi_ddict <- read_csv("../data/toronto-ksi-2024-06-13-datadict.csv")
ksi_ddict
```

### Details

```{r}
print(toronksi_raw)
```

### Files

The data files are available below:

- [toronto-ksi-2024-06-13.csv](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-ksi-2024-06-13.csv)
- [toronto-ksi-2024-06-13-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-ksi-2024-06-13-datadict.csv)

## Vancouver KSI

Private data.

```{r}
vancksi_raw <- read.csv("../tmp/TAS persons involved in crashes in Vancouver 2010-2021.csv")
```

## Calgary KSI

Private data.

```{r}
calgksi_raw <- read.csv("../tmp/Combined Collision Data for Calgary (2016 - 2021).csv") %>%
	filter(CASE_YEAR < 2021) %>%
	mutate(
		OCCURENCE_TIMESTAMP = as.Date(OCCURENCE_TIMESTAMP, origin = "1899-12-30") # excel date serial numbers
	) %>%
	add_row(
		read.csv("../tmp/Collision Data for Calgary (2021 - 2022).csv") %>%
			mutate(OCCURENCE_TIMESTAMP = OCCURENCE_TIMESTAMP %>% as_datetime)
	)
```

# Cleaning

## Combine Bikeways {.tabset}

Combine bikeway data across all cities using common columns.

Also modifies column `id` to store a unique identifier in the format of `<CITY>_<CITY_ID>`.

**Note**: For Calgary and Toronto, there weren't any included bikeways that were not verified (e.g. Local Street Bikeways (LSBs)), and a dummy column was added to account for this case.

**Note 2**: Bikeway lengths were also calculated in meters as an additional column `geometry_len_meters`.

```{r}

# List of city bikeway data
bike_list <- list(
	vancouver = vancbike_raw %>%
		mutate(
			build_status = "EXISTING"
		),
	calgary = calgbike_raw %>%
		mutate(
			no_verify_install_type = NA,
			build_status = str_to_upper(status)
		),
	toronto = toronbike_raw %>%
		mutate(
			no_verify_install_type = NA,
			build_status = "EXISTING"
		)
)

# Get common columns across all city bikeways
bike_cols <- bike_list %>%
	map(colnames) %>%
	reduce(intersect)

# Combine bikeway data across cities
bike_combine <- names(bike_list) %>%
	map(function(city) {
		bike_list[[city]] %>%
			select(
				all_of(bike_cols)
			) %>%
			mutate(
				city = city,
				city_id = id,
				.before = 1
			)
	}) %>%
	reduce(add_row) %>%
	mutate(
		id = paste0(city, "_", city_id)
	) %>%
	mutate(
		geometry_len_meters = st_length(geometry) %>% as.numeric
	)

```

### Details

```{r}

# Display combined bikeway rows and cols
cat(glue(
	"\n* Rows: ", bike_combine %>% nrow,
	"\n* Columns: ", bike_combine %>% ncol
))

# Display rows per city
bike_combine_counts <- bike_combine %>%
	as_tibble %>%
	group_by(city) %>% count
bike_combine_counts

```

### Preview

```{r}

# Display combined bikeway data
bike_combine %>% as_tibble %>% head

```

## Combine KSI {.tabset}

Combine KSI data across cities using common columns.

Also adds column `ksi_id` to store a unique identifier in the format of `<CITY>_<CITY_ID>`.

**Note**: For Vancouver, columns were duplicated to represent individuals injured or killed.

**Note 2**: KSI records for Vancouver only had month and year - thus the day was set to the first of each month to be consistent with Toronto and Calgary data.

```{r}

# Vancouver ksi
vancksi <- vancksi_raw %>%
	uncount(VICTIM_COUNT) %>%
	st_as_sf(
		coords = c("LONGITUDE", "LATITUDE"),
		crs = 4326,
		na.fail = F
	) %>%
	mutate(
		ksi_city = "vancouver",
		ksi_city_id = 1:nrow(.) %>% as.character,
		ksi_date = as_date(glue("{YEAR}-{MONTH}-01")), # assume first day
		ksi_severity = INJURY_TYPE %>% as.character,
		ksi_user = ROLE %>% as.character
	) %>%
	select(
		ksi_city,
		ksi_city_id,
		ksi_date,
		ksi_severity,
		ksi_user
	)

# Calgary ksi
calgksi <- calgksi_raw %>%
	st_as_sf(
		coords = c("LOC_GPS_LONG", "LOC_GPS_LAT"),
		crs = 4326,
		na.fail = F
	) %>%
	mutate(
		ksi_city = "calgary",
		ksi_city_id = 1:nrow(.)  %>% as.character,
		ksi_date = OCCURENCE_TIMESTAMP,
		ksi_severity = INJURY_SEVERITY %>% as.character,
		ksi_user = Object.Type %>% as.character
	) %>%
	mutate(
		ksi_user = case_when(
			ksi_user == "Bicyclist" ~ "Cyclist",
			.default = ksi_user
		),
	) %>%
	select(
		ksi_city,
		ksi_city_id,
		ksi_date,
		ksi_severity,
		ksi_user
	)

# Toronto ksi
toronksi <- toronksi_raw %>%
	mutate(
		ksi_city = "toronto",
		ksi_city_id = INDEX %>% as.character,
		ksi_date = DATE %>% as_date,
		ksi_severity = ACCLASS %>% as.character,
		ksi_user = INVTYPE %>% as.character
	) %>%
	select(
		ksi_city,
		ksi_city_id,
		ksi_date,
		ksi_severity,
		ksi_user
	)

# Combine KSI data
ksi_combine <- calgksi %>%
	add_row(vancksi) %>%
	add_row(toronksi) %>%
	mutate(
		ksi_id = paste0(ksi_city, "_", ksi_city_id)
	)

```

### Details

```{r}

# Display combined ksi rows and cols
cat(glue(
	"\n* Rows: ", ksi_combine %>% nrow,
	"\n* Columns: ", ksi_combine %>% ncol
))

# Display rows per city
ksi_combine_counts <- ksi_combine %>%
	as_tibble %>%
	group_by(ksi_city) %>%
	count
ksi_combine_counts

```

### Preview

```{r}

# Display combined ksi data
ksi_combine %>% as_tibble %>% select(-geometry) %>% filter(ksi_city == "toronto") %>% head

```

## Filter KSI with Coordinates {.tabset}

Filter KSI data with coordinates only.

```{r}

# Filter for ksi with coords
ksi_coords <- ksi_combine %>%
	filter(!st_is_empty(geometry))

```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", ksi_combine %>% nrow,
	"\n* Columns: ", ksi_combine %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", ksi_coords %>% nrow,
	"\n* Columns: ", ksi_coords %>% ncol
))

# Display missing coordinates per city
ksi_coords_counts <- ksi_combine %>%
	as_tibble %>%
	group_by(ksi_city) %>%
	count %>%
	left_join(
		ksi_coords %>%
			as_tibble %>%
			group_by(ksi_city) %>%
			count(name = "n_coords"),
		by = "ksi_city"
	) %>%
	mutate(
		n_miss_coords = n - n_coords,
		perc_coords = n_coords / n * 100,
		perc_miss_coords = n_miss_coords / n * 100
	)
ksi_coords_counts

```

### Preview

```{r}

# Display filtered rows
ksi_coords %>% as_tibble %>% select(-geometry) %>% filter(ksi_city == "toronto") %>% head

```

## Filter KSI Severity {.tabset}

Filter KSI data for fatal and serious injuries only.

```{r}

# Filter for fatal or serious injuries only
ksi_injury <- ksi_coords %>%
	filter(ksi_severity %in% c(
		"Major Injuries",
		"Fatality",
		"Non-Fatal Injury",
		"Fatal",
		"Fatal injury",
		"Serious injury - Overnight at hospital"
	))

```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", ksi_coords %>% nrow,
	"\n* Columns: ", ksi_coords %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", ksi_injury %>% nrow,
	"\n* Columns: ", ksi_injury %>% ncol
))

# Display counts
ksi_injury_counts <- ksi_coords %>%
	as_tibble %>%
	group_by(ksi_city, ksi_severity) %>%
	count
ksi_injury_counts

```

### Preview

```{r}

# Display filtered rows
ksi_injury %>% as_tibble %>% select(-geometry) %>% filter(ksi_city == "toronto") %>% head

```

## Filter Verified Bikeways {.tabset}

Filter for bikeways with verified installations or upgrades.

```{r}

# Filter verified bikeways
bike_verify <- bike_combine %>%
	filter(!city %in% c("calgary", "vancouver")) %>%
	add_row( # calgary filters appendix 2
		bike_combine %>%
			filter(
				city == "calgary" &
				install_type %in% c("Bicycle Lane", "Cycle Track") &
				!build_status %in% c("INACTIVE", "PLANNED")
			)
	) %>%
	add_row( # vancouver filters appendix 2
		bike_combine %>%
	    filter(
	        city == "vancouver" &
	            install_type %in% c("Painted Lanes", "Protected Bike Lanes", "Local Street") &
	            road_type != "Off-street"
	    )
	) %>%
	filter(
		(!is.na(verify_install_year) |
		!is.na(verify_upgrade1_year) |
		!is.na(verify_upgrade2_year)) &
		is.na(no_verify_install_type) &
		is.na(verify_misclass) &
		!st_is_empty(geometry)
	) %>%
	distinct(geometry, .keep_all = TRUE) # remove duplicate geoms

```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", bike_combine %>% nrow,
	"\n* Columns: ", bike_combine %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", bike_verify %>% nrow,
	"\n* Columns: ", bike_verify %>% ncol
))

# Display counts
bike_verify_counts <- bike_verify %>%
	as_tibble %>%
	pivot_longer(
		c(
			verify_install_year,
			verify_upgrade1_year,
			verify_upgrade2_year
		),
		names_to = "column",
		values_to = "value"
	) %>%
	mutate(
		status = case_when(
			str_starts(column, "verify_install") ~ "install",
			str_starts(column, "verify_upgrade1") ~ "upgrade1",
			str_starts(column, "verify_upgrade2") ~ "upgrade2"
		)
	) %>%
	group_by(status, value) %>%
	count
bike_verify_counts

```

### Preview

```{r}

# Display filtered rows
bike_verify %>%
	as_tibble %>%
	select(
		verify_install_year,
		verify_upgrade1_year,
		verify_upgrade2_year,
		no_verify_install_type,
		everything()
	) %>%
	arrange(`verify_install_year`) %>%
	head

```

## Filter Infrastructure Types {.tabset}

Filter for painted lanes (`PL` and `BUF`) and cycle tracks (`PBL`) only in any of `verify_install_type`, `verify_upgrade1_type`, and `verify_upgrade2_type`.

```{r}

# Remove none or na bike types
bike_itypes <- bike_verify %>%
	filter(
		verify_install_type %in% c("PL", "BUF", "PBL") |
		verify_upgrade1_type %in% c("PL", "BUF", "PBL") |
		verify_upgrade2_type %in% c("PL", "BUF", "PBL")
	)

```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", bike_verify %>% nrow,
	"\n* Columns: ", bike_verify %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", bike_itypes %>% nrow,
	"\n* Columns: ", bike_itypes %>% ncol
))

# Display counts
bike_itypes_counts <- bike_itypes %>%
	as_tibble %>%
	filter(
		verify_install_type %in% c("PL", "BUF", "PBL")
	) %>%
	mutate(
		type = verify_install_type
	) %>%
	group_by(type) %>%
	count %>%
	ungroup %>%
	add_row(
		bike_itypes %>%
			as_tibble %>%
			filter(
				!verify_install_type %in% c("PL", "BUF", "PBL") &
				verify_upgrade1_type %in% c("PL", "BUF", "PBL")
			) %>%
			mutate(
				type = glue("{verify_install_type} (Install) to {verify_upgrade1_type} (1st Upgrade)")
			) %>%
			group_by(type) %>%
			count
	) %>%
	add_row(
		bike_itypes %>%
			as_tibble %>%
			filter(
				!verify_install_type %in% c("PL", "BUF", "PBL") &
				!verify_upgrade1_type %in% c("PL", "BUF", "PBL") &
				verify_upgrade2_type %in% c("PL", "BUF", "PBL")
			) %>%
			mutate(
				type = glue("{verify_install_type} to {verify_upgrade1_type} (1st Upgrade) to {verify_upgrade2_type} (2nd Upgrade)")
			) %>%
			group_by(type) %>%
			count
	)
bike_itypes_counts

```

### Preview

```{r}

# Preview filtered bike types data
bike_itypes %>% as_tibble %>% head

```

## Fix Unknown Installs {.tabset}

If installations are neither painted lane `PL`, buffered lane `BUF`, or cycle track `PBL`, then use upgrade1 as the installation and upgrade2 as the first upgrade if available.

This shifts upgrade1 into the install, and upgrade2 into upgrade1, while setting upgrade2 as `NA`.

```{r}

# Shift upgrade1 and upgrade2 left if install is not PL/BUF/PBL
bike_unknown <- bike_itypes %>%
	mutate(
		`_install_unknown` = if_else( # whether install was not PL/BUF/PBL
			!is.na(verify_install_type) &
				!verify_install_type %in% c("PL", "BUF", "PBL"),
			TRUE,
			FALSE
		),
		verify_install_type = if_else( # set install to upgrade1
			`_install_unknown`,
			verify_upgrade1_type,
			verify_install_type
		),
		verify_install_date = if_else(
			`_install_unknown`,
			verify_upgrade1_date,
			verify_install_date
		),
		verify_install_year = if_else(
			`_install_unknown`,
			verify_upgrade1_year,
			verify_install_year
		),
		verify_upgrade1_type = if_else( # set upgrade1 to upgrade2
			`_install_unknown`,
			verify_upgrade2_type,
			verify_upgrade1_type
		),
		verify_upgrade1_date = if_else(
			`_install_unknown`,
			verify_upgrade2_date,
			verify_upgrade1_date
		),
		verify_upgrade1_year = if_else(
			`_install_unknown`,
			verify_upgrade2_year,
			verify_upgrade1_year
		),
		verify_upgrade2_type = if_else( # set upgrade2 to na
			`_install_unknown`,
			NA,
			verify_upgrade2_type
		),
		verify_upgrade2_date = if_else(
			`_install_unknown`,
			NA,
			verify_upgrade2_date
		),
		verify_upgrade2_year = if_else(
			`_install_unknown`,
			NA,
			verify_upgrade2_year
		)
	)

```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", bike_itypes %>% nrow,
	"\n* Columns: ", bike_itypes %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", bike_unknown %>% nrow,
	"\n* Columns: ", bike_unknown %>% ncol,
	"\n\nNew Columns (", bike_unknown %>% ncol - bike_itypes %>% ncol, ")\n",
	paste0(
		"\n* ",
		colnames(bike_unknown) %>%
			.[!. %in% colnames(bike_itypes)],
		collapse = ""
	)
))

# Display counts
bike_unknown_counts <- bike_unknown %>%
	mutate(
		history = paste0(
			verify_install_type,
			" -> ",
			verify_upgrade1_type,
			" -> ",
			verify_upgrade2_type
		)
	) %>%
	as_tibble() %>%
	select(-geometry) %>%
	arrange(history) %>%
	group_by(history) %>%
	summarize(
		unknown = sum(`_install_unknown`),
		n = n()
	) %>%
	add_row(
		history = "TOTAL",
		unknown = sum(.[["unknown"]]),
		n = sum(.[["n"]])
	)
bike_unknown_counts

```

### Preview

```{r}

# Display clean dates cols
bike_unknown %>%
	as_tibble() %>%
	select(-geometry) %>%
	select(
		starts_with("_install_unknown"),
		verify_install_type,
		verify_upgrade1_type,
		verify_upgrade2_type,
		everything()
	) %>%
	arrange(desc(`_install_unknown`)) %>%
	head()

```

## Apply Improvements {.tabset}

Apply whether there were bikeway improvements or not for each bikeway segment.

Bikeway improvements occur when the installation was upgraded either once or twice, but resulted in the same bikeway type.

For the first upgrade `v_improve1`, this is `TRUE` when the installation is the same type as the first upgrade. The first upgrade will be moved to the `_improve1_type`, `_improve1_date`, and `_improve1_year` columns.

For the second upgrade `_improve2`, this is `TRUE` when the first upgrade is the same type as the second upgrade. The second upgrade will be moved to the `_improve2_type`, `_improve2_date`, and `_improve2_year` columns.

```{r}

# Add columns to indicate whether a bikeway has an improvement
bike_improv <- bike_unknown %>%
	mutate(
		`_improve1` = if_else( # whether upgrade1 was an improvement
			!is.na(verify_upgrade1_type) &
			verify_install_type == verify_upgrade1_type,
			TRUE,
			FALSE
		),
		`_improve2` = if_else( # whether upgrade2 was an improvement
			!is.na(verify_upgrade2_type) &
			verify_upgrade2_type == verify_upgrade1_type,
			TRUE,
			FALSE
		),
		`_improve` = `_improve1` | `_improve2` # whether there was an improvement
	) %>%
	mutate( # create improve1 columns
		`_improve1_type` = if_else(`_improve1`, verify_upgrade1_type, NA),
		`_improve1_date` = if_else(`_improve1`, verify_upgrade1_date, NA),
		`_improve1_year` = if_else(`_improve1`, verify_upgrade1_year, NA)
	) %>%
	mutate( # create improve2 columns
		`_improve2_type` = if_else(`_improve2`, verify_upgrade2_type, NA),
		`_improve2_date` = if_else(`_improve2`, verify_upgrade2_date, NA),
		`_improve2_year` = if_else(`_improve2`, verify_upgrade2_year, NA)
	) %>%
	mutate( # remove improve1 upgrades
		`verify_upgrade1_type` = if_else(`_improve1`, NA, verify_upgrade1_type),
		`verify_upgrade1_date` = if_else(`_improve1`, NA, verify_upgrade1_date),
		`verify_upgrade1_year` = if_else(`_improve1`, NA, verify_upgrade1_year)
	) %>%
	mutate( # remove improve2 upgrades
		`verify_upgrade2_type` = if_else(`_improve2`, NA, verify_upgrade2_type),
		`verify_upgrade2_date` = if_else(`_improve2`, NA, verify_upgrade2_date),
		`verify_upgrade2_year` = if_else(`_improve2`, NA, verify_upgrade2_year)
	)

```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", bike_unknown %>% nrow,
	"\n* Columns: ", bike_unknown %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", bike_improv %>% nrow,
	"\n* Columns: ", bike_improv %>% ncol,
	"\n\nNew Columns (", bike_improv %>% ncol - bike_unknown %>% ncol, ")\n",
	paste0(
		"\n* ",
		colnames(bike_improv) %>%
			.[!. %in% colnames(bike_unknown)],
		collapse = ""
	)
))

# Display counts
bike_improv_counts <- bike_improv %>%
	mutate(
		history = paste0(
			verify_install_type,
			" -> ",
			verify_upgrade1_type,
			" -> ",
			verify_upgrade2_type
		)
	) %>%
	as_tibble() %>%
	select(-geometry) %>%
	arrange(history) %>%
	group_by(history) %>%
	summarize(
		improve1 = sum(`_improve1`),
		improve2 = sum(`_improve2`),
		n = n()
	) %>%
	add_row(
		history = "TOTAL",
		improve1 = sum(.[["improve1"]]),
		improve2 = sum(.[["improve2"]]),
		n = sum(.[["n"]])
	)
bike_improv_counts

```

### Preview

```{r}

# Display clean dates cols
bike_improv %>%
	as_tibble() %>%
	select(-geometry) %>%
	select(
		starts_with("_improve"),
		verify_install_type,
		verify_upgrade1_type,
		verify_upgrade2_type,
		everything()
	) %>%
	arrange(desc(`_improve`)) %>%
	head()

```

## Apply Removals {.tabset}

Apply whether there were bikeway removals or not for each bikeway segment.

Bikeway removals occur when an upgrade is neither a painted lane `PL`, buffered lane `BUF` or cycle track `PBL`, signalling that the previous installation or upgrade was removed.

For the first upgrade `_remove1`, this is `TRUE` when the first upgrade `None` or `N`. The second upgrade will be moved to the first upgrade, while the first upgrade will be stored in columns `_remove1_type`, `_remove1_date`, and `_remove1_year`.

For the second upgrade `_remove2`, this is `TRUE` when the second upgrade is `None` or `N`. The second upgrade will be removed stored in columns `_remove2_type`, `_remove2_date`, and `_remove2_year`.

```{r}

# Add columns to indicate whether a bikeway has a removal
bike_remove <- bike_improv %>%
	mutate(
		`_remove1` = if_else( # whether upgrade1 was a removal
			!is.na(verify_upgrade1_type) &
				!verify_upgrade1_type %in% c("PL", "BUF", "PBL"),
			TRUE,
			FALSE
		),
		`_remove2` = if_else( # whether upgrade2 was a removal
			!is.na(verify_upgrade2_type) &
				!verify_upgrade2_type %in% c("PL", "BUF", "PBL"),
			TRUE,
			FALSE
		),
		`_remove` = `_remove1` | `_remove2` # whether there was a removal
	) %>%
	mutate( # create remove1 columns
		`_remove1_type` = if_else(`_remove1`, verify_upgrade1_type, NA),
		`_remove1_date` = if_else(`_remove1`, verify_upgrade1_date, NA),
		`_remove1_year` = if_else(`_remove1`, verify_upgrade1_year, NA)
	) %>%
	mutate( # create remove2 columns
		`_remove2_type` = if_else(`_remove2`, verify_upgrade1_type, NA),
		`_remove2_date` = if_else(`_remove2`, verify_upgrade1_date, NA),
		`_remove2_year` = if_else(`_remove2`, verify_upgrade1_year, NA)
	) %>%
	mutate( # apply remove2
		`verify_upgrade2_type` = if_else(
			`_remove2`,
			NA,
			verify_upgrade2_type
		),
		`verify_upgrade2_date` = if_else(
			`_remove2`,
			NA,
			verify_upgrade2_date
		),
		`verify_upgrade2_year` = if_else(
			`_remove2`,
			NA,
			verify_upgrade2_year
		)
	) %>%
	mutate( # apply remove1
		`verify_upgrade1_type` = if_else( # shift upgrade2 to upgrade1
			`_remove1`,
			verify_upgrade2_type,
			verify_upgrade1_type
		),
		`verify_upgrade1_date` = if_else(
			`_remove1`,
			verify_upgrade2_date,
			verify_upgrade1_date
		),
		`verify_upgrade1_year` = if_else(
			`_remove1`,
			verify_upgrade2_year,
			verify_upgrade1_year
		),
		`verify_upgrade2_type` = if_else( # remove upgrade2 after shift
			`_remove1`,
			NA,
			verify_upgrade2_type
		),
		`verify_upgrade2_date` = if_else(
			`_remove1`,
			NA,
			verify_upgrade2_date
		),
		`verify_upgrade2_year` = if_else(
			`_remove1`,
			NA,
			verify_upgrade2_year
		)
	)

```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", bike_improv %>% nrow,
	"\n* Columns: ", bike_improv %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", bike_remove %>% nrow,
	"\n* Columns: ", bike_remove %>% ncol,
	"\n\nNew Columns (", bike_remove %>% ncol - bike_improv %>% ncol, ")\n",
	paste0(
		"\n* ",
		colnames(bike_remove) %>%
			.[!. %in% colnames(bike_improv)],
		collapse = ""
	)
))

# Display counts
bike_remove_counts <- bike_remove %>%
	mutate(
		history = paste0(
			verify_install_type,
			" -> ",
			verify_upgrade1_type,
			" -> ",
			verify_upgrade2_type
		)
	) %>%
	as_tibble() %>%
	select(-geometry) %>%
	arrange(history) %>%
	group_by(history) %>%
	summarize(
		remove1 = sum(`_remove1`),
		remove2 = sum(`_remove2`),
		n = n()
	) %>%
	add_row(
		history = "TOTAL",
		remove1 = sum(.[["remove1"]]),
		remove2 = sum(.[["remove2"]]),
		n = sum(.[["n"]])
	)
bike_remove_counts

```

### Preview

```{r}

# Display clean dates cols
bike_remove %>%
	as_tibble() %>%
	select(-geometry) %>%
	select(
		starts_with("_remove"),
		verify_install_type,
		verify_upgrade1_type,
		verify_upgrade2_type,
		everything()
	) %>%
	arrange(desc(`_remove`)) %>%
	head()

```


## Filter Post-2010 Bikeways {.tabset}

Filter for bikeways with a verified installations or upgrades after 2010.

```{r}

# Filter bikeways for post2010
bike_p2010 <- bike_remove %>%
	filter(
		verify_install_year > 2010 |
		verify_upgrade1_year > 2010 |
		verify_upgrade2_year > 2010
	)

```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", bike_remove %>% nrow,
	"\n* Columns: ", bike_remove %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", bike_p2010 %>% nrow,
	"\n* Columns: ", bike_p2010 %>% ncol
))

# Display counts
bike_p2010_counts <- bike_p2010 %>%
	as_tibble %>%
	pivot_longer(
		c(
			verify_install_year,
			verify_upgrade1_year,
			verify_upgrade2_year
		),
		names_to = "column",
		values_to = "value"
	) %>%
	mutate(
		status = case_when(
			str_starts(column, "verify_install") ~ "install",
			str_starts(column, "verify_upgrade1") ~ "upgrade1",
			str_starts(column, "verify_upgrade2") ~ "upgrade2"
		)
	) %>%
	group_by(status, value) %>%
	count
bike_p2010_counts

```

### Preview

```{r}

# Display filtered rows
bike_p2010 %>%
	as_tibble %>%
	select(
		verify_install_year,
		verify_upgrade1_year,
		verify_upgrade2_year,
		everything()
	) %>%
	arrange(`verify_install_year`) %>%
	head

```

## Filter 2009-2023 KSI {.tabset}

Filter for KSI records between 2009 and 2023 inclusively.

```{r}

# Filter ksi for post2010
ksi_y2009to2023 <- ksi_injury %>%
	filter(year(ksi_date) >= 2009 & year(ksi_date) <= 2023)

```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", ksi_injury %>% nrow,
	"\n* Columns: ", ksi_injury %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", ksi_y2009to2023 %>% nrow,
	"\n* Columns: ", ksi_y2009to2023 %>% ncol
))

# Display counts
ksi_y2009to2023_counts <- ksi_y2009to2023 %>%
	as_tibble %>%
	group_by(year(ksi_date)) %>%
	count
ksi_y2009to2023_counts

```

### Preview

```{r}

# Display filtered rows
ksi_y2009to2023 %>%
	as_tibble %>%
	select(
		ksi_date,
		everything()
	) %>%
	arrange(year(ksi_date)) %>%
	filter(ksi_city == "toronto") %>%
	head

```

## Add Bikeway Dates {.tabset}

Join ambiguous verified install/upgrade/improve/remove dates (e.g. Jan 1/2022, 2022/02, Fall 2020) to manually cleaned dates with structured time units (e.g. days, months, quarters, semesters, ranges) and date formats (e.g. 2022-01-01, 2022-02-01).

```{r}

# Join clean dates to include structured date formats
bike_dates <- bike_p2010 %>%
	left_join( # install dates
		vdates_raw %>%
			rename_with(~ paste0("_install_", .x)),
		by = join_by(verify_install_date == `_install_verify_date_raw`)
	) %>%
	left_join( # upgrade1 dates
		vdates_raw %>%
			rename_with(~ paste0("_upgrade1_", .x)),
		by = join_by(verify_upgrade1_date == `_upgrade1_verify_date_raw`)
	) %>%
	left_join( # upgrade2 dates
		vdates_raw %>%
			rename_with(~ paste0("_upgrade2_", .x)),
		by = join_by(verify_upgrade2_date == `_upgrade2_verify_date_raw`)
	) %>%
	left_join( # improve1 dates
		vdates_raw %>%
			rename_with(~ paste0("_improve1_", .x)),
		by = join_by(`_improve1_date` == `_improve1_verify_date_raw`)
	) %>%
	left_join( # improve2 dates
		vdates_raw %>%
			rename_with(~ paste0("_improve2_", .x)),
		by = join_by(`_improve2_date` == `_improve2_verify_date_raw`)
	) %>%
	left_join( # remove1 dates
		vdates_raw %>%
			rename_with(~ paste0("_remove1_", .x)),
		by = join_by(`_remove1_date` == `_remove1_verify_date_raw`)
	) %>%
	left_join( # remove2 dates
		vdates_raw %>%
			rename_with(~ paste0("_remove2_", .x)),
		by = join_by(`_remove2_date` == `_remove2_verify_date_raw`)
	)

```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", bike_p2010 %>% nrow,
	"\n* Columns: ", bike_p2010 %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", bike_dates %>% nrow,
	"\n* Columns: ", bike_dates %>% ncol,
	"\n\nNew Columns (", bike_dates %>% ncol - bike_p2010 %>% ncol, ")\n",
	paste0(
		"\n* ",
		colnames(bike_dates) %>%
			.[!. %in% colnames(bike_p2010)],
		collapse = ""
	)
))

# Display counts
bike_dates_counts <- bike_dates %>%
    as_tibble %>%
    pivot_longer(
        c(
            verify_install_year,
            verify_upgrade1_year,
            verify_upgrade2_year
        ),
        names_to = "status",
        values_to = "status_year"
    ) %>%
    mutate(
        status = case_when(
            str_starts(status, "verify_install") ~ "install",
            str_starts(status, "verify_upgrade1") ~ "upgrade1",
            str_starts(status, "verify_upgrade2") ~ "upgrade2"
        )
    ) %>%
    group_by(city, status) %>%
    summarize(
        n = sum(!is.na(status_year))
    ) %>%
	left_join(
		bike_dates %>%
		    as_tibble %>%
		    pivot_longer(
		        c(
		            `_install_verify_date_type`,
		            `_upgrade1_verify_date_type`,
		            `_upgrade2_verify_date_type`
		        ),
		        names_to = "status",
		        values_to = "status_date_type"
		    ) %>%
		    mutate(
		        status = case_when(
		            str_starts(status, "_install") ~ "install",
		            str_starts(status, "_upgrade1") ~ "upgrade1",
		            str_starts(status, "_upgrade2") ~ "upgrade2"
		        )
		    ) %>%
		    group_by(city, status) %>%
		    summarize(
		        n_with_dates = sum(!is.na(status_date_type))
		    ),
		by = c("city", "status")
	) %>%
	mutate(
		n_without_dates = n - n_with_dates
	) %>%
	select(
		city,
		status,
		n_with_dates,
		n_without_dates,
		n
	)
bike_dates_counts

```

### Preview

```{r}

# Display clean dates cols
bike_dates %>%
	as_tibble %>%
	select(starts_with(c("_install_", "_upgrade1_", "_upgrade2_")), everything()) %>%
	arrange(`_install_verify_date_type`)

```

## Add Time Units {.tabset .tabset-pills}

Add the following time unit columns for installs/upgrades in bikeways and for each ksi record:

* `_time_month`: which month (1, 2, 3 ... 12) a bikeway had a verified installation/upgrade or ksi record
* `_time_quarter`: which quarter (1, 2, 3, 4) of the year a bikeway had a verified installation/upgrade or ksi record
* `_time_third`: which third (1, 2, 3) of the year a bikeway had a verified installation/upgrade or ksi record
* `_time_half`: which half (1, 2) of the year a bikeway had a verified installation/upgrade or ksi record
* `_time_semester`: which semester (1, 2) of the year a bikeway had a verified installation/upgrade or ksi record, where:
	* `1`: represents May to October of this year
	* `2`: represents November (this year) to April of next year
* `_time_year`: standardized year column that bikeway had verified installation/upgrade or ksi record
* `_time_..._group`: grouped columns of the above defining the time units in textual format
* Install records follow the patterns above prefixed with `_install`
* Upgrade records are prefixed with `_upgrade1` and `_upgrade2`
* KSI records will follow the same patterns above except prefixed with `_ksi` as well
* Additional columns for installs and upgrades only:
	* `_assign_semester`: if the date falls between semester 1 or 2 and was automatically assigned to semester 1 or 2 based on the larger number of days in either semester 1 or 2
	* `_assign_semester_1_days`: number of days in semester 1 if the date falls between semesters
	* `_assign_semester_2_days`: number of days in semester 2 if the date falls between semesters
	* If the number of days are equal, then semester 2 is assigned by default

**Note**: Date ranges that fall between months, quarters, thirds, or halves of the year were excluded from being classified as any of the time units (e.g. March 31 to April 15 will be excluded as it does not fall within either the 1st or 2nd quarter of the year).

```{r}

#' Add Time Units to Data Frame
#'
#' This function takes a data frame and adds new columns representing various time units such as month, quarter, third, half, and semester. These columns are derived from a date column or if the time unit is more than day, then additiona start and end date columns
#'
#' @param df A data frame that contains the columns `verify_date`, `verify_date_type`, `verify_date_start`, and `verify_date_end`.
#' @param date_col Name of the date column to use
#' @param start_col Name of the start date column to use
#' @param end_col Name of the end date column to use
#' @param type_col Name of the date type column to use (e.g. month, day, year, etc)
#' @param prefix Additional text to add to the output column names
#' @param assign_semester Whether to assign intervals between semesters to be in the semester with the max duration that the interval falls in. When durations are equal, semester 2 will be chosen.
#'
#' @return A data frame with additional columns (without `prefix`):
#' \describe{
#'   \item{`_time_month`}{Numeric representation of the month (1-12).}
#'   \item{`_time_month_group`}{Unique time group for month.}
#'   \item{`_time_quarter`}{Quarter of the year (1-4).}
#'   \item{`_time_quarter_group`}{Unique time group for quarter.}
#'   \item{`_time_third`}{Third of the year (1-3).}
#'   \item{`_time_third_group`}{Unique time group for third.}
#'   \item{`_time_half`}{Half of the year (1-2).}
#'   \item{`_time_half_group`}{Unique time group for half.}
#'   \item{`_time_semester`}{Custom semester (1 for May-Oct, 2 for Nov-Apr).}
#'   \item{`_assign_semester`}{Whether the date was assigned since it did not fall between either semester 1 or 2.}
#'   \item{`_assign_semester_1_days`}{Number of days that the date is in semester 1 if `assign_semester` is `TRUE`.}
#'   \item{`_assign_semester_2_days`}{Number of days that the date is in semester 2 if `assign_semester` is `TRUE`.}
#'   \item{`_time_semester_group`}{Unique time group for semester.}
#'   \item{`_time_year`}{4-digit year.}
#' }
#'
#' @examples
#' \dontrun{
#' df <- data.frame(
#'   verify_date = as.Date(c("2021-01-15", "2021-06-20", "2021-09-10")),
#'   verify_date_type = c("day", "month", "day"),
#'   verify_date_start = as.Date(c("2021-01-01", "2021-06-01", "2021-09-01")),
#'   verify_date_end = as.Date(c("2021-01-31", "2021-06-30", "2021-09-30"))
#' )
#' result <- add_time_units(df)
#' print(result)
#' }
#'
#' @import dplyr
#' @importFrom lubridate month year
#' @export
add_time_units <- function(
	df,
	date_col = "_install_verify_date",
	start_col = "_install_verify_date_start",
	end_col = "_install_verify_date_end",
	type_col = "_install_verify_date_type",
	year_col = "verify_install_year",
	prefix = NULL,
	assign_semester = T
) {
	
	# Code time units
	out <- df %>%
		mutate( # rename req cols
			`_date` = .data[[date_col]],
			`_start` = .data[[start_col]],
			`_end` = .data[[end_col]],
			`_type` = .data[[type_col]],
			`_year` = .data[[year_col]]
		) %>%
		mutate( # add time units
			
			# Months (monthly)
			`_time_month` = case_when(
				`_type` %in% c("day", "month") ~ month(`_date`, label = T, abbr = F)
			),
			`_time_month` = as.numeric(`_time_month`),
			
			# Quarters (quarterly)
			`_time_quarter` = case_when(
				month(`_date`) %in% 1:3 |
				(
					month(`_start`) %in% 1:3 &
					month(`_end`) %in% 1:3 &
					year(`_start`) == year(`_end`)
				) ~ 1,
				month(`_date`) %in% 4:6 |
				(
					month(`_start`) %in% 4:6 &
					month(`_end`) %in% 4:6 &
					year(`_start`) == year(`_end`)
				) ~ 2,
				month(`_date`) %in% 7:9 |
				(
					month(`_start`) %in% 7:9 &
					month(`_end`) %in% 7:9 &
					year(`_start`) == year(`_end`)
				) ~ 3,
				month(`_date`) %in% 10:12 |
				(
					month(`_start`) %in% 10:12 &
					month(`_end`) %in% 10:12 &
					year(`_start`) == year(`_end`)
				) ~ 4
			),
			
			# Thirds (triyearly)
			`_time_third` = case_when(
				month(`_date`) %in% 1:4 |
				(
					month(`_start`) %in% 1:4 &
					month(`_end`) %in% 1:4 &
					year(`_start`) == year(`_end`)
				) ~ 1, # Fall
				month(`_date`) %in% 5:8 |
				(
					month(`_start`) %in% 5:8 &
					month(`_end`) %in% 5:8 &
					year(`_start`) == year(`_end`)
				) ~ 2, # Winter
				month(`_date`) %in% 9:12 |
				(
					month(`_start`) %in% 9:12 &
					month(`_end`) %in% 9:12 &
					year(`_start`) == year(`_end`)
				) ~ 3 # Spring/Summer
			),
			
			# Halves (biyearly)
			`_time_half` = case_when(
				month(`_date`) %in% 1:6 |
				(
					month(`_start`) %in% 1:6 &
					month(`_end`) %in% 1:6 &
					year(`_start`) == year(`_end`)
				) ~ 1,
				month(`_date`) %in% 7:12 |
				(
					month(`_start`) %in% 7:12 &
					month(`_end`) %in% 7:12 &
					year(`_start`) == year(`_end`)
				) ~ 2
			),
			
			# Semester (custom range)
			`_time_semester` = case_when(
				month(`_date`) %in% 5:10 | # May to Oct (this year)
				(
					month(`_start`) %in% 5:10 &
					month(`_end`) %in% 5:10 &
					year(`_start`) == year(`_end`)
				) ~ 1,
				month(`_date`) %in% c(11:12, 1:4) | # Nov (this/last year) to Apr (next/this year)
				(
					month(`_start`) %in% c(11:12, 1:4) &
					month(`_end`) %in% c(11:12, 1:4) &
					year(`_start`) <= (year(`_end`) + 1)
				) ~ 2
			),
			
			# Year
			`_time_year` = `_year`
			
		)
	
	# For intervals between semesters, assign in max duration
	if (assign_semester) {
		out <- out %>%
			mutate( # add intervals for semesters and date
				`_assign_semester_1_interval_1` = interval( # sem 1 this year
		            start = glue("{`_year`}-05-01") %>% as_date,
		            end = glue("{`_year`}-10-31") %>% as_date
		        ),
		        `_assign_semester_2_interval_1` = interval( # sem 2 this to next year
		            start = glue("{`_year`}-11-01") %>% as_date,
		            end = glue("{`_year` + 1}-04-30") %>% as_date
		        ),
				`_assign_semester_2_interval_2` = interval( # sem 2 last to this year
		            start = glue("{`_year` - 1}-11-01") %>% as_date,
		            end = glue("{`_year`}-04-30") %>% as_date
		        ),
				`_assign_date_interval` = if_else( # only for non-assigned sem
					!is.na(`_start`) & !is.na(`_end`) & is.na(`_time_semester`),
					interval(`_start`, `_end`),
					NA
				)
			) %>%
			mutate( # get duration in days
				`_assign_semester_1_days` = coalesce(
					intersect(
						`_assign_date_interval`,
						`_assign_semester_1_interval_1`
					)
				) %>% as.numeric / (3600 * 24),
				`_assign_semester_2_days` = coalesce(
					intersect(
						`_assign_date_interval`,
						`_assign_semester_2_interval_1`
					),
					intersect(
						`_assign_date_interval`,
						`_assign_semester_2_interval_2`
					)
				) %>% as.numeric / (3600 * 24)
			) %>%
			mutate( # assign semester
				`_time_semester` = if_else(
					!is.na(`_assign_date_interval`),
					case_when(
						`_assign_semester_1_days` == `_assign_semester_2_days` ~ 2, # break ties to sem 2
						`_assign_semester_1_days` > `_assign_semester_2_days` ~ 1, # sem 1
						`_assign_semester_1_days` < `_assign_semester_2_days` ~ 2 # sem 2
					),
					`_time_semester`
				),
				`_assign_semester` = if_else(
					!is.na(`_assign_semester_1_days`) | !is.na(`_assign_semester_2_days`),
					TRUE,
					FALSE
				)
			) %>%
			select(-c( # remove unwanted cols
				`_assign_semester_1_interval_1`,
				`_assign_semester_2_interval_1`,
				`_assign_semester_2_interval_2`,
				`_assign_date_interval`
			))
	}
	
	# Add time groups that include the year
	out <- out %>%
		mutate(
			
			# Month group
			`_time_month_group` = if_else(
				!is.na(`_time_month`),
				glue("{`_year`}_{`_time_month`}"),
				NA
			),
			
			# Quarter group
			`_time_quarter_group` = if_else(
				!is.na(`_time_quarter`),
				glue("{`_year`}_{`_time_quarter`}"),
				NA
			),
			
			# Third group
			`_time_third_group` = if_else(
				!is.na(`_time_third`),
				glue("{`_year`}_{`_time_third`}"),
				NA
			),
			
			# Half group
			`_time_half_group` = if_else(
				!is.na(`_time_half`),
				glue("{`_year`}_{`_time_half`}"),
				NA
			),
			
			# Semester group
			`_time_semester_group` = if_else(
				!is.na(`_time_semester`),
				glue("{`_year`}_{`_time_semester`}"),
				NA
			),
			
			# Year group
			`_time_year_group` = if_else(
				!is.na(`_time_year`),
				glue("{`_year`}"),
				NA
			)
			
		)
	
	# Add prefix to time unit cols
	if (!is.null(prefix)) {
		out <- out %>%
			rename_with( # add prefix
				~ paste0(prefix, .x),
				starts_with("_time_")
			)
	}
	
	# Remove time cols
	out <- out %>%
		select(-c(
			`_date`,
			`_start`,
			`_end`,
			`_type`,
			`_year`
		))
	return(out)
}

```

### Bikeways {.tabset}

```{r}

# Add time unit columns using func for bikeways
bike_tunits <- bike_dates %>%
	add_time_units( # install tunits
		date_col = "_install_verify_date",
		start_col = "_install_verify_date_start",
		end_col = "_install_verify_date_end",
		type_col = "_install_verify_date_type",
		year_col = "verify_install_year",
		prefix = "_install"
	) %>%
	add_time_units( # upgrade1 tunits
		date_col = "_upgrade1_verify_date",
		start_col = "_upgrade1_verify_date_start",
		end_col = "_upgrade1_verify_date_end",
		type_col = "_upgrade1_verify_date_type",
		year_col = "verify_upgrade1_year",
		prefix = "_upgrade1"
	) %>%
	add_time_units( # upgrade2 tunits
		date_col = "_upgrade2_verify_date",
		start_col = "_upgrade2_verify_date_start",
		end_col = "_upgrade2_verify_date_end",
		type_col = "_upgrade2_verify_date_type",
		year_col = "verify_upgrade2_year",
		prefix = "_upgrade2"
	) %>%
	add_time_units( # improve1 tunits
		date_col = "_improve1_verify_date",
		start_col = "_improve1_verify_date_start",
		end_col = "_improve1_verify_date_end",
		type_col = "_improve1_verify_date_type",
		year_col = "_improve1_year",
		prefix = "_improve1"
	) %>%
	add_time_units( # improve2 tunits
		date_col = "_improve2_verify_date",
		start_col = "_improve2_verify_date_start",
		end_col = "_improve2_verify_date_end",
		type_col = "_improve2_verify_date_type",
		year_col = "_improve2_year",
		prefix = "_improve2"
	) %>%
	add_time_units( # remove1 tunits
		date_col = "_remove1_verify_date",
		start_col = "_remove1_verify_date_start",
		end_col = "_remove1_verify_date_end",
		type_col = "_remove1_verify_date_type",
		year_col = "_remove1_year",
		prefix = "_remove1"
	) %>%
	add_time_units( # remove2 tunits
		date_col = "_remove2_verify_date",
		start_col = "_remove2_verify_date_start",
		end_col = "_remove2_verify_date_end",
		type_col = "_remove2_verify_date_type",
		year_col = "_remove2_year",
		prefix = "_remove2"
	)

```

#### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", bike_dates %>% nrow,
	"\n* Columns: ", bike_dates %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", bike_tunits %>% nrow,
	"\n* Columns: ", bike_tunits %>% ncol,
	"\n\nNew Columns (", bike_tunits %>% ncol - bike_dates %>% ncol, ")\n",
	paste0(
		"\n* ",
		colnames(bike_tunits) %>%
			.[!. %in% colnames(bike_dates)],
		collapse = ""
	)
))

# Display counts
bike_tunits_counts <- bike_tunits %>%
    as_tibble %>%
	pivot_longer(
		ends_with("_group"),
		names_to = "column",
		values_to = "value"
	) %>%
	mutate(
		status = case_when(
			str_starts(column, "_install") ~ "install",
			str_starts(column, "_upgrade1") ~ "upgrade1",
			str_starts(column, "_upgrade2") ~ "upgrade2"
		),
		time_unit = str_replace_all(
			column,
			"_install_time_|_upgrade1_time_|_upgrade2_time_|_group",
			""
		)
	) %>%
	filter(!is.na(value)) %>%
	group_by(status, time_unit) %>%
	count
bike_tunits_counts

```

#### Preview

```{r}

# Display time unit cols for bikeways
bike_tunits %>%
	as_tibble %>%
	select(
		starts_with("_"),
		everything()
	) %>%
	arrange(`_install_verify_date`) %>%
	head

```

### KSI {.tabset}

```{r}

# Add time unit columns using func for ksi
ksi_tunits <- ksi_y2009to2023 %>%
	mutate( # add cols to standardize func params
		`_ksi_date` = ksi_date,
		`_ksi_date_start` = NA,
		`_ksi_date_end` = NA,
		`_ksi_date_type` = "day",
		`_ksi_year` = year(ksi_date)
	) %>%
	add_time_units(
		date_col = "_ksi_date",
		start_col = "_ksi_date_start",
		end_col = "_ksi_date_end",
		type_col = "_ksi_date_type",
		year_col = "_ksi_year",
		prefix = "_ksi",
		assign_semester = F
	)

```

#### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", ksi_y2009to2023 %>% nrow,
	"\n* Columns: ", ksi_y2009to2023 %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", ksi_tunits %>% nrow,
	"\n* Columns: ", ksi_tunits %>% ncol,
	"\n\nNew Columns (", ksi_tunits %>% ncol - ksi_y2009to2023 %>% ncol, ")\n",
	paste0(
		"\n* ",
		colnames(ksi_tunits) %>%
			.[!. %in% colnames(ksi_injury)],
		collapse = ""
	)
))

# Display counts
ksi_tunits_counts <- ksi_tunits %>%
    as_tibble %>%
	pivot_longer(
		ends_with("_group"),
		names_to = "column",
		values_to = "value"
	) %>%
	mutate(
		time_unit = str_replace_all(
			column,
			"_ksi_time_|_group",
			""
		)
	) %>%
	filter(!is.na(value)) %>%
	group_by(time_unit) %>%
	count
ksi_tunits_counts

```

#### Preview

```{r}

# Display time unit cols for ksi
ksi_tunits %>%
	as_tibble %>%
	filter(ksi_city == "toronto") %>%
	select(
		ksi_date,
		starts_with("_")
	) %>%
	arrange(year(ksi_date)) %>%
	head

```

## Determine Time Unit {.tabset .tabset-pills}

For bikeways, determine the temporal resolution (unit of time) finer than yearly based on the amount of data available per time unit (sorted from the highest resolution time unit to the lowest resolution time unit):

* **Month** (high): refers to verified post-2010 installs and upgrades occurring approximately in a month (1/12) of a year
* **Quarter**: refers to verified post-2010 installs and upgrades occurring approximately in a quarter (1/4) of a year
* **Third**: refers to verified post-2010 installs and upgrades occurring approximately in a third (1/3) of a year
* **Half** (low): refers to verified post-2010 installs and upgrades occurring approximately in a half (1/2) of a year
* **Semester** (low): refers to verified post-2010 installs and upgrades occurring approximately in a half (1/2) of a year with the first half (1) being November (same year) to April (next year) and the second half being May to October (next year)

The `year` was selected as the time unit.

```{r}

plot_time_units <- function(
		df,
		month_col = "_install_time_month",
		quarter_col = "_install_time_quarter",
		third_col = "_install_time_third",
		half_col = "_install_time_half",
		semester_col = "_install_time_semester",
		year_col = "_install_time_year",
		title = "% of Verified Post-2010 Installs by Unit of Time",
		overlap_gap = 10.5,
		expand = c(0.18, 0),
		city_nudge_x = 0.25
) {
	
	# Prepare plot data
	plot_data <- df %>%
		as_tibble %>%
		mutate( # assign time unit cols
			`_time_month` = .data[[month_col]],
			`_time_quarter` = .data[[quarter_col]],
			`_time_third` = .data[[third_col]],
			`_time_half` = .data[[half_col]],
			`_time_semester` = .data[[semester_col]],
			`_time_year` = .data[[year_col]]
		) %>%
		group_by(city) %>%
		summarize( # calc installs/upgrades for each time unit
			Month = sum(!is.na(`_time_month`)),
			Quarter = sum(!is.na(`_time_quarter`)),
			Third = sum(!is.na(`_time_third`)),
			Half = sum(!is.na(`_time_half`)),
			Semester = sum(!is.na(`_time_semester`)),
			Year = sum(!is.na(`_time_year`))
		) %>%
		pivot_longer(
			cols = -city,
			names_to = "type",
			values_to = "n"
		) %>%
		mutate( # zero as NA
			n = if_else(n == 0, NA, n)
		) %>%
		left_join( # Add city totals
			df %>%
				as_tibble %>%
				group_by(city) %>%
				count(name = "total"),
			by = "city"
		) %>%
		ungroup %>%
	    mutate( # calc percentages and add labels
	        type = factor(type, levels = c("Month", "Quarter", "Third", "Half", "Semester", "Year")),
	        city = factor(str_to_title(city), levels = c("Vancouver", "Calgary", "Toronto")),
	        perc = n / total * 100,
	        perc_label = glue(
	        	"{str_sub(city, end = 1)}: {round(perc, 2)}%\n",
	        	"(n={format(n, big.mark = ',', scientific = F)})"
	        )
	    ) %>%
	    group_by(type) %>% # adjust overlapping labels
	    arrange(desc(perc)) %>% 
		mutate(
	        perc_before = lag(perc),
	        perc_after = lead(perc),
	        perc_order = 0:(length(perc) - 1)
	    ) %>%
	    mutate( # detect overlap labels and shift down and up
	        perc_label_y = case_when(
	            lag(perc) == perc | lead(perc) == perc ~ max(perc) - (perc_order * overlap_gap),
	            lag(perc) - perc < 10 ~ max(perc) - (perc_order * overlap_gap),
	            .default = perc
	        )
	    ) %>%
		group_by(city) %>%
		mutate( # add city labels at end of lines
			city_label = if_else(
				type == "Year",
				glue(
					"{city}\n",
					"(n={format(total, big.mark = ',', scientific = F)})"
				),
				NA
			)
		) %>%
		ungroup %>%
	    arrange(city, type)
	
	# Get time unit totals
	unit_total <- sum(plot_data$total %>% unique, na.rm = T)
	unit_total_label <- format(unit_total, big.mark = ",", scientific = F)
	
	# Plot time units
	out <- plot_data %>%
		ggplot(aes(
			x = type,
			y = perc,
			group = city,
			color = city,
			label = perc_label
		)) +
		geom_line(
			alpha = 0.8,
			linewidth = 1.5
		) +
		geom_label(
			aes(y = perc_label_y),
			size = 2.25,
			show.legend = F,
			label.padding = unit(0.5, "lines")
		) +
		geom_text(
			aes(
				label = city_label,
				y = perc_label_y
			),
			size = 2.5,
			show.legend = F,
			hjust = 0,
			nudge_x = city_nudge_x
		) +
		scale_y_continuous(
			limits = c(0, 100),
			labels = function(x) paste0(x, "%")
		) +
		scale_x_discrete(
			limits = levels(plot_data$type),
			position = "top",
			expand = expand
		) +
		labs(
			title = glue(
				"{title}\n",
				"(n={unit_total_label})"
			),
			x = NULL,
			y = NULL,
			color = "City",
			label = NULL,
			group = NULL
		) +
		theme_minimal() +
		theme(
			legend.position = "none",
			plot.title = element_text(hjust = 0.5)
		)
	return(out)
}

# Select time unit
tunit <- "year"

```

### Install {.tabset}

#### Plot

```{r}
plot_time_units(bike_tunits)
```

#### Details

```{r}
bike_tunits %>%
	as_tibble %>%
	group_by(city, `_install_time_semester`) %>%
	count %>%
	group_by(city) %>%
	mutate(perc = round(n / sum(n) * 100, 2))
```

### 1st Upgrade {.tabset}

#### Plot

```{r}
plot_time_units(
	bike_tunits %>% filter(!is.na(verify_upgrade1_year)),
	month_col = "_upgrade1_time_month",
	quarter_col = "_upgrade1_time_quarter",
	third_col = "_upgrade1_time_third",
	half_col = "_upgrade1_time_half",
	semester_col = "_upgrade1_time_semester",
	year_col = "_upgrade1_time_year",
	title = "% of Verified Post-2010 1st Upgrades by Unit of Time"
)
```

#### Details

```{r}
bike_tunits %>%
	as_tibble %>%
	filter(!is.na(verify_upgrade1_year)) %>%
	group_by(city, `_upgrade1_time_semester`) %>%
	count %>%
	group_by(city) %>%
	mutate(perc = round(n / sum(n) * 100, 2))
```

### 2nd Upgrade {.tabset}

#### Plot

```{r}
plot_time_units(
	bike_tunits %>% filter(!is.na(verify_upgrade2_year)),
	month_col = "_upgrade2_time_month",
	quarter_col = "_upgrade2_time_quarter",
	third_col = "_upgrade2_time_third",
	half_col = "_upgrade2_time_half",
	semester_col = "_upgrade2_time_semester",
	year_col = "_upgrade2_time_year",
	title = "% of Verified Post-2010 2nd Upgrades by Unit of Time",
	expand = c(0.2, 0),
	city_nudge_x = 0.35
)
```

#### Details

```{r}
bike_tunits %>%
	as_tibble %>%
	filter(!is.na(verify_upgrade2_year)) %>%
	group_by(city, `_upgrade1_time_semester`) %>%
	count %>%
	group_by(city) %>%
	mutate(perc = round(n / sum(n) * 100, 2))
```

## Filter Timed Bikeways {.tabset}

Filter for bikeways with time unit values that were installed/upgraded post-2010.

```{r}
bike_tfilter <- bike_tunits %>%
	filter(
		(verify_install_year > 2010 & !is.na(.data[[glue("_install_time_{tunit}")]])) |
		(verify_upgrade1_year > 2010 & !is.na(.data[[glue("_upgrade1_time_{tunit}")]])) |
		(verify_upgrade2_year > 2010 & !is.na(.data[[glue("_upgrade1_time_{tunit}")]])) 
	)
```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", bike_tunits %>% nrow,
	"\n* Columns: ", bike_tunits %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", bike_tfilter %>% nrow,
	"\n* Columns: ", bike_tfilter %>% ncol
))

# Display counts
bike_sem_counts <- bike_tfilter %>%
    as_tibble %>%
	pivot_longer(
		c(
			verify_install_year,
			verify_upgrade1_year,
			verify_upgrade2_year
		),
		names_to = "column",
		values_to = "value"
	) %>%
	mutate(
		status = case_when(
			str_starts(column, "verify_install") ~ "install",
			str_starts(column, "verify_upgrade1") ~ "upgrade1",
			str_starts(column, "verify_upgrade2") ~ "upgrade2"
		)
	) %>%
	group_by(city, status, value) %>%
	count
bike_sem_counts

```

### Preview

```{r}

# Display merged bike segments
bike_tfilter %>%
	as_tibble %>%
	select(-geometry) %>%
	head

```

## Group Adjacent Bikeways {.tabset}

Group bikeway segments together if they are spatially adjacent and are the same latest infrastructure type after all installs and upgrades.

This also adds an additional columns `_adj_group1` (considering spatial adjacency only) and `_adj_group2` (considering spatial adjacency and latest type) specifying the adjacency group in the format of `<CITY>_<ADJID>` and `<CITY>_<TYPE>_<ADJID>` respectively, where:

* `<CITY>`: is the city name
* `<TYPE>`: the latest infrastructure type of the segment
* `<ADJID>`: the adjacency id, if the ids are the same, they are adjacent in space

Other merge related columns start with `_adj_....`

**Note**: Only infrastructure with different types are considered an upgrade. Infrastructure with the same type are considered improvements and do not affect the known status.

```{r}

# Determine adjacent segments if they are within same status, type, and time unit
bike_adj <- bike_tfilter %>%
    mutate( # add column to store status, type, and time unit
        `_adj_status` = case_when(
            !is.na(.data[[glue("_upgrade2_time_{tunit}")]]) ~ "upgrade2",
            !is.na(.data[[glue("_upgrade1_time_{tunit}")]]) ~ "upgrade1",
            !is.na(.data[[glue("_install_time_{tunit}")]]) ~ "install"
        ),
        `_adj_status_time_group` = case_when(
        	`_adj_status` == "upgrade2" ~ .data[[glue("_upgrade2_time_{tunit}_group")]],
            `_adj_status` == "upgrade1" ~ .data[[glue("_upgrade1_time_{tunit}_group")]],
            `_adj_status` == "install" ~ .data[[glue("_install_time_{tunit}_group")]]
        ),
        `_adj_status_time_year` = str_split_i(`_adj_status_time_group`, "_", 1) %>% as.integer,
        `_adj_status_time_value` = coalesce(
        	str_split_i(`_adj_status_time_group`, "_", 2) %>% as.integer,
        	`_adj_status_time_year`
        ),
        `_adj_type` = case_when(
            `_adj_status` == "upgrade2" ~ verify_upgrade2_type,
            `_adj_status` == "upgrade1" ~ verify_upgrade1_type,
            `_adj_status` == "install" ~ verify_install_type
        )
    ) %>%
	mutate( # add adj group for spatial only
		`_adj_group1` = bike_tfilter %>%
	        st_touches %>%
	        graph_from_adj_list %>%
	        components %>%
	        .$membership,
		`_adj_group1` = paste0(city, "_", `_adj_group1`)
	) %>%
    group_by(city, `_adj_type`) %>%
    group_map(~ {
        
        # Assign group id as group_by values separated by underscore
        group_id <- .y[1,] %>%
            as.character %>%
            paste0(., collapse = "_") %>%
            str_to_lower(.)
        
        # Find adjacent segments and group them together using a group id
        adj_group2 <- .x %>%
            st_touches %>%
            graph_from_adj_list %>%
            components %>%
            .$membership %>%
            paste0(group_id, "_", .)
        
        # Assign adj group to data in order
        out <- .x %>% mutate(`_adj_group2` = adj_group2)
        return(out)
        
    }, .keep = T) %>%
    reduce(add_row)

```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", bike_tfilter %>% nrow,
	"\n* Columns: ", bike_tfilter %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", bike_adj %>% nrow,
	"\n* Columns: ", bike_adj %>% ncol,
	"\n\nNew Columns (", bike_adj %>% ncol - bike_tfilter %>% ncol, ")\n",
	paste0(
		"\n* ",
		colnames(bike_adj) %>%
			.[!. %in% colnames(bike_tfilter)],
		collapse = ""
	)
))

# Display counts
bike_adj_counts <- bike_adj %>%
    as_tibble %>%
	group_by(`_adj_group2`) %>%
	count
bike_adj_counts

```

### Preview

```{r}

# Display merged bike segments
bike_adj %>%
	as_tibble %>%
	select(starts_with("_adj"), everything(), -geometry) %>%
	head

```

### Map

```{r}
tmap_mode("view")
tm_shape(bike_adj %>% select(-ends_with("comment"))) +
	tm_lines(
		group = "Segments (Red)",
		col = "red",
		lwd = 1.5,
		popup.vars = T
	) +
	tm_shape(bike_adj %>% st_cast("POINT")) +
	tm_dots(group = NULL, col = "red", size = 0.03)
```


## Join KSI to Bikeways {.tabset}

Spatially join KSI to nearest bikeways, where each KSI point is joined to the nearest bikeway and the distance to that joined bikeway is calculated in meters.

```{r}

# Get bike ids and geoms
bike_adj_ids <- bike_adj %>% select(id)

# Get indices of nearest bikeway for each ksi
sjoin_idx <- ksi_tunits %>%
	st_nearest_feature(bike_adj_ids)

# Spatial join bikeways with ksi keeping ids
sjoin <- ksi_tunits %>%
	mutate( # calc dist to nearest bikeway for each ksi
		`_sjoin_meters` = st_distance(
			geometry,
			bike_adj_ids[sjoin_idx, ],
			by_element = T
		) %>% as.numeric
	) %>%
	as_tibble %>%
	select(-geometry) %>%
	mutate( # set bikeway ids
		id = bike_adj_ids[sjoin_idx, ] %>% pull(id)
	) %>%
	select(id, ksi_id, ksi_city, `_sjoin_meters`)

```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBikeways\n",
	"\n* Rows: ", bike_adj %>% nrow,
	"\n* Columns: ", bike_adj %>% ncol,
	"\n\nKSI\n",
	"\n* Rows: ", ksi_tunits %>% nrow,
	"\n* Columns: ", ksi_tunits %>% ncol,
	"\n\nSpatial Join Keys\n",
	"\n* Rows: ", sjoin %>% nrow,
	"\n* Columns: ", sjoin %>% ncol,
	"\n* Rows Spatially Joined (Bikeways): ",
	sjoin %>%
		filter(!is.na(id)) %>%
		pull(id) %>%
		unique %>%
		length,
	"\n* Rows Spatially Joined (KSI): ",
	sjoin %>%
		filter(!is.na(ksi_id)) %>%
		pull(ksi_id) %>%
		unique %>%
		length
))

```


### Preview

```{r}

# Display spatially joined ids
sjoin %>%
	filter(!is.na(ksi_id)) %>%
	head

```

## Count KSI Per Time Unit {.tabset}

For each bikeway, count KSI spatially joined to bikeways per unit of time.

This creates columns in the format of `_ksi_time_<UNIT>_<YEAR>_<VALUE>`, where:

* `<UNIT>`: is the unit of time, either `month`, `quarter`, `half`, or `semester`
* `<YEAR>`: is the year for the unit of time
* `<VALUE>`: is the number representing the portion of the time range for the unit of time with month being 1-12, quarter being 1-4, third being 1-3, half being 1-2 and semester being 1-2 (this is omitted if time unit is `year`)

KSI by road users and different distances (25, 50, >25-150, >150-250, >250-350, >350-450, >450-550, >150-550 meters) to bikeways will also be counted according to the Ling et al. (2020) paper with a modification for an addition of 25 and 50 meter distances with the inclusion of decimal distances between cutoffs (instead of 151-250 we use >150-250 to capture decimal numbers between 150 and 151):

Ling, R., Rothman, L., Cloutier, M. S., Macarthur, C., & Howard, A. (2020). Cyclist-motor vehicle collisions before and after implementation of cycle tracks in Toronto, Canada. Accident Analysis & Prevention, 135, 105360.

```{r}

# Ensure ids are same data type
sjoin <- sjoin %>%
	mutate(
		id = as.character(id),
		ksi_id = as.character(ksi_id)
	)
ksi_tunits <- ksi_tunits %>%
	mutate(
		ksi_id = as.character(ksi_id)
	)

# Get time unit col
tunit_col <- glue("_ksi_time_{tunit}_group")

# Set ksi dist to bikeways according to ling paper 2020
bike_sjoin_dist <- c(
	"25",
	"50",
	"25to150",
	"150to250",
	"250to350",
	"350to450",
	"450to550",
	"150to550"
)
bike_sjoin_cols <- expand_grid(
	dist = bike_sjoin_dist,
	user = c("all", "driver", "pedestrian", "cyclist", "other")
) %>%
	mutate(
		column = paste0("ksi_user_", user, "_", dist, "m")
	) %>%
	pull(dist, name = "column")

# Create ksi road user and buffer flag cols and agg by bikeways
bike_sjoin <- bike_adj %>%
	mutate(
		id = as.character(id)
	) %>%
	full_join( # add spatial joins
		sjoin,
		by = "id"
	) %>%
	full_join( # add ksi
		ksi_tunits %>%
			as_tibble %>%
			select(-geometry, -ksi_city),
		by = "ksi_id"
	) %>%
	mutate( # calc ksi user flags
		ksi_user_driver = if_else(
			ksi_user %in% c("Driver", "Passenger", "Truck Driver"), 1, 0
		),
		ksi_user_pedestrian = if_else(
			ksi_user == "Pedestrian", 1, 0
		),
		ksi_user_cyclist = if_else(
			ksi_user %in% c("Cyclist", "Cyclist Passenger"), 1, 0
		),
		ksi_user_other = (
			!(ksi_user_driver | ksi_user_pedestrian | ksi_user_cyclist)
		) %>% as.integer
	) %>%
	add_column( # init ksi user flags with dist
		!!!as.list(bike_sjoin_cols)
	) %>%
	mutate(across( # all ksi within single dist flag
		starts_with("ksi_user_all") & matches("_\\d+m$"),
		~ if_else(
			!is.na(ksi_user) & `_sjoin_meters` <= as.numeric(.x),
			1,
			0
		)
	)) %>%
	mutate(across( # all ksi within additive dist flag
		starts_with("ksi_user_all") & matches("_\\d+to\\d+m$"),
		~ if_else(
			!is.na(ksi_user) &
			`_sjoin_meters` > as.numeric(str_split_1(.x %>% unique, "to")[1]) &
			`_sjoin_meters` <= as.numeric(str_split_1(.x %>% unique, "to")[2]),
			1,
			0
		)
	)) %>%
	mutate(across( # ksi by users with single dist flags
		starts_with("ksi_user_") &
		!starts_with("ksi_user_all") &
		matches("_\\d+m$"),
		~ if_else(
			get(str_replace(cur_column(), "_\\d+m$", "")) == 1 &
			`_sjoin_meters` <= as.numeric(.x),
			1,
			0
		)
	)) %>%
	mutate(across( # ksi by users with additive dist flags
		starts_with("ksi_user_") &
		!starts_with("ksi_user_all") &
		matches("_\\d+to\\d+m$"),
		~ if_else(
			get(str_replace(cur_column(), "_\\d+to\\d+m$", "")) == 1 &
			`_sjoin_meters` > as.numeric(str_split_1(.x %>% unique, "to")[1]) &
			`_sjoin_meters` <= as.numeric(str_split_1(.x %>% unique, "to")[2]),
			1,
			0
		)
	)) %>%
	group_by(across(c(
		"id",
		tunit_col
	))) %>%
	summarize( # count all and per road user type
		`_count_ksi_user` = n(),
		across(
			starts_with("ksi_user_"),
			~ sum(.x, na.rm = T),
			.names = "_count_{.col}"
		),
		across(
			!starts_with("_count_"),
			~ paste0(.x, collapse = ",")
		)
	) %>%
	rename_with( # rename to count instead of user for agg
		~str_replace(.x, "_count_ksi_user", "ksi_count"),
		starts_with("_count_ksi_user")
	) %>%
	rename_with( # remove all from col name for simplicity
		~str_replace(.x, "ksi_count_all", "ksi_count"),
		starts_with("ksi_count_all")
	) %>%
	mutate( # set counts to 0 if not joined
		across(starts_with("ksi_count"), ~replace_na(.x, 0))
	)

# Create combination of all id and time unit combos
if (tunit != "year") {
	
	# Create time unit combos for finer than a year
	tunit_combo <- expand_grid(
	    id = unique(bike_adj$id),
	    year = min(year(ksi_tunits$ksi_date)):max(year(ksi_tunits$ksi_date)),
	    time_value = unique(ksi_tunits[[glue("_ksi_time_{tunit}")]])
	) %>%
	    mutate(
	    	!!tunit_col := glue("{year}_{time_value}")
	    ) %>%
	    select(-year, -time_value)
	
} else {
	
	# Create time unit combos for year
	tunit_combo <- expand_grid(
	    id = unique(bike_adj$id),
	    !!tunit_col := min(year(ksi_tunits$ksi_date)):max(year(ksi_tunits$ksi_date))
	) %>%
		mutate(!!tunit_col := .data[[tunit_col]] %>% as.character)
	
}

# Fill in missing time units as zero
bike_ksi <- tunit_combo %>%
	left_join(
		bike_adj,
		by = "id"
	) %>%
	left_join(
		bike_sjoin %>%
			as_tibble %>%
			select(c(
				id,
				tunit_col,
				starts_with("ksi_count"),
				colnames(ksi_tunits)
			)) %>%
			select(-geometry),
		by = c("id", tunit_col)
	) %>%
	mutate(across(
		starts_with("ksi_count"),
		~replace_na(.x, 0)
	))

```

### Details {.tabset .tabset-pills}

```{r}

# Calc ksi counts per road user and dist to bikeway
bike_ksi_counts <- bike_sjoin %>%
	as_tibble %>%
	select(-geometry) %>%
    pivot_longer(
        starts_with("ksi_count"),
        names_to = "column",
        values_to = "value"
    ) %>%
    mutate(
        user = str_remove_all( # extract user
            column,
            "ksi_count|_|\\d+m$|\\d+to\\d+m$"
        ) %>%
            if_else(. == "", "all", .),
        dist_min = case_when( # extract min dist to bike
        	str_detect(column, "\\d+to\\d+m$") ~
        		str_extract(column, "\\d+") %>%
        		as.numeric,
        	str_detect(column, "\\d+m$") ~
        		0,
        	.default = NA
        ),
        dist_max = case_when( # extract max dist to bike
        	str_detect(column, "\\d+to\\d+m$") ~
        		str_remove(str_extract(column, "\\d+m$"), "m") %>%
        		as.numeric,
        	str_detect(column, "\\d+m$") ~
        		str_extract(column, "\\d+") %>%
        		as.numeric,
        	.default = NA
        ),
        is_dist = if_else(!is.na(dist_min) | !is.na(dist_max), T, F),
        dist = if_else(
        	dist_min == 0,
        	glue("{dist_max} meters"),
        	glue("{dist_min} to {dist_max} meters")
        )
    ) %>%
	rowwise %>%
	mutate(
		city = str_split_1(city, ",") %>%
			unique
	) %>%
    select(city, ksi = value, user, dist, is_dist, dist_min, dist_max)

```

#### Changes

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", bike_adj %>% nrow,
	"\n* Columns: ", bike_adj %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", bike_ksi %>% nrow,
	"\n* Columns: ", bike_ksi %>% ncol,
	"\n\nNew Columns (", bike_ksi %>% ncol - bike_adj %>% ncol, ")\n",
	paste0(
		"\n* ",
		colnames(bike_ksi) %>%
			.[!. %in% colnames(bike_adj)],
		collapse = ""
	)
))

```

#### KSI Counts Per Distance

```{r}

# Table of total counts per city, user, and dist to bikeway
bike_ksi_agg <- bike_ksi_counts %>%
	filter(!is.na(dist)) %>%
	group_by(city, user, dist) %>%
	summarize(
		ksi = sum(ksi, na.rm = T),
		dist_min = unique(dist_min),
		dist_max = unique(dist_max)
	) %>%
	arrange(user, city, dist_min)
bike_ksi_agg %>%
	select(-dist_min, -dist_max)

# Save table
bike_ksi_agg %>%
	select(-dist_min, -dist_max) %>%
	write_csv("../data/recovr-eval-dist-2024-11-12.csv")

```

```{r}

# Display plot of details
bike_ksi_agg %>%
	filter(
		user == "all" &
			!dist %in% c("50 meters", "150 to 550 meters")
	) %>%
	mutate(
		city = factor(
			str_to_title(city),
			levels = c("Vancouver", "Calgary", "Toronto")
		),
		dist = factor(
			str_replace(dist, " meters", ""),
			levels = str_replace(bike_sjoin_dist, "to", " to ")
		)
	) %>%
	ggplot(aes(x = dist, y = ksi, color = city, label = ksi, group = city)) +
	geom_line() +
	geom_point() +
	geom_text_repel(size = 2.5) +
	labs(
		x = "Distance to Nearest Bikeway (Meters)",
		y = "KSI Individuals",
		color = "City"
	) +
	theme_minimal()
```

#### Distance Histogram

```{r}
sjoin %>%
	filter(`_sjoin_meters` < 20000) %>%
	ggplot(aes(x = `_sjoin_meters`)) +
	geom_histogram(binwidth = 100) +
	facet_wrap(~ksi_city) +
	labs(
		x = "Distances of KSI to Closest Bikeway (Meters)",
		y = "Frequency",
		title = "Distances < 20,000 Meters",
		caption = glue("*There were only {sjoin %>% filter(`_sjoin_meters` > 20000) %>% nrow} KSIs outside the distance of 20,000 meters which were assumed to be outliers.")
	) +
	theme_minimal()
```


### Preview

```{r}

# Display merged bikeways with ksi counts
bike_ksi %>%
	filter(!is.na(ksi_id)) %>%
	select(starts_with("ksi_count"), everything()) %>%
	head

```

## Prepare Model Data {.tabset}

**Note 1**: If a time falls below the study period's time range, the cohort will be considered `1` (existing since the beginning of the time range).

**Note 2**: Post is dependent on cohort, unless there is a removal. In the case of a removal, all installs and upgrades will determine the 1's in post, while the removals will be applied to set the 1's to 0's in post.

```{r}

# Extract year and time unit for time ids
if (tunit != "year") {
	
	# Time units more fine than a year
	tid_data <- bike_ksi %>%
		mutate(
			time_group = .data[[glue("_ksi_time_{tunit}_group")]] %>%
				replace_na("NA") %>%
				str_split_1(., ",") %>%
				unique
		) %>%
		separate(
			time_group,
			c("year", tunit),
			sep = "_"
		) %>%
		select(year, time_value)
	
} else {
	
	# Time unit as year
	tid_data <- bike_ksi %>%
		rowwise %>%
		mutate(
			time_value = .data[[glue("_ksi_time_{tunit}")]] %>%
				replace_na("NA") %>%
				str_split_1(., ",") %>%
				unique %>%
				as.numeric,
			year = time_value
		) %>%
		select(year, time_value)
	
}

# Assign time ids using ordered levels
if (tunit != "year") {
	
	# Get uniq combinations as ids
	tid <- expand_grid(
		time_year = min(tid_data$year, na.rm = T):max(tid_data$year, na.rm = T),
		time_value = unique(tid_data$time_value)
	) %>%
	    arrange(time_year, time_value) %>%
	    mutate(
	    	time_orig = glue("{time_year}_{time_value}"),
	    	time = factor(time_orig) %>% as.integer
	    )
	
} else {
	
	# Get year as ids
	tid <- data.frame(
		time_year = min(tid_data$year, na.rm = T):max(tid_data$year, na.rm = T)
	) %>%
		mutate(
			time_value = time_year,
			time_orig = time_value %>% as.character,
			time = factor(time_orig) %>% as.integer
		)
	
}

# Create time id map list
tid_map <- Map(reformulate, shQuote(tid$time), shQuote(tid$time_orig))

# Prepare model data
model_data <- bike_ksi %>%
	mutate( # add bike history in format of inst_type(year) -> upgr_type(year) -> upgr2_type(year)
        verify_history = paste0(
            verify_install_type,
            "(", verify_install_year, ")", " -> ",
            verify_upgrade1_type,
            "(", verify_upgrade1_year, ")", " -> ",
            verify_upgrade2_type,
            "(", verify_upgrade2_year, ")"
        ),
    ) %>%
	select(
		bike_id = id,
		bike_adj_group1 = `_adj_group1`,
		bike_adj_group2 = `_adj_group2`,
		bike_city = city,
		bike_status = `_adj_status`,
		bike_type = `_adj_type`,
		bike_len_meters = geometry_len_meters,
		bike_time_orig = `_adj_status_time_group`,
		bike_year = `_adj_status_time_year`,
		bike_time = `_adj_status_time_value`,
		bike_history = verify_history,
		bike_install_type = verify_install_type,
		bike_install_year = verify_install_year,
		bike_install_time_orig = .data[[glue("_install_time_{tunit}_group")]],
		bike_install_comment = verify_install_comment,
		bike_install_unknown = `_install_unknown`,
		bike_upgrade1_type = verify_upgrade1_type,
		bike_upgrade1_year = verify_upgrade1_year,
		bike_upgrade1_time_orig = .data[[glue("_upgrade1_time_{tunit}_group")]],
		bike_upgrade1_comment = verify_upgrade1_comment,
		bike_upgrade2_type = verify_upgrade2_type,
		bike_upgrade2_year = verify_upgrade2_year,
		bike_upgrade2_time_orig = .data[[glue("_upgrade2_time_{tunit}_group")]],
		bike_upgrade2_comment = verify_upgrade2_comment,
		bike_improve = `_improve`,
		bike_improve1 = `_improve1`,
		bike_improve1_type = `_improve1_type`,
		bike_improve1_year = `_improve1_year`,
		bike_improve1_time_orig = .data[[glue("_improve1_time_{tunit}_group")]],
		bike_improve2 = `_improve2`,
		bike_improve2_type = `_improve2_type`,
		bike_improve2_year = `_improve2_year`,
		bike_improve2_time_orig = .data[[glue("_improve2_time_{tunit}_group")]],
		bike_remove = `_remove`,
		bike_remove1 = `_remove1`,
		bike_remove1_type = `_remove1_type`,
		bike_remove1_year = `_remove1_year`,
		bike_remove1_time_orig = .data[[glue("_remove1_time_{tunit}_group")]],
		bike_remove2 = `_remove2`,
		bike_remove2_type = `_remove2_type`,
		bike_remove2_year = `_remove2_year`,
		bike_remove2_time_orig = .data[[glue("_remove2_time_{tunit}_group")]],
		ksi_time_orig = .data[[glue("_ksi_time_{tunit}_group")]],
		starts_with("ksi_count")
	) %>%
	rename_with( # adjust ksi col names
		~str_replace(.x, "ksi_count", "ksi"),
		starts_with("ksi_count")
	) %>%
	left_join( # add values about range of data
		ksi_y2009to2023 %>%
			as_tibble() %>%
			group_by(ksi_city) %>%
			summarize(
				ksi_year_min = min(year(ksi_date)),
				ksi_year_max = max(year(ksi_date))
			),
		by = join_by(bike_city == ksi_city)
	) %>%
	separate( # get year and time value
		ksi_time_orig,
		c("ksi_year", "ksi_time"),
		sep = "_",
		remove = F,
		convert = T
	) %>%
	mutate( # set ksi count to na if not within data year range
		ksi = if_else(
			ksi_year < ksi_year_min | ksi_year > ksi_year_max,
			NA,
			ksi
		),
		ksi_driver = if_else(is.na(ksi), NA, ksi_driver),
		ksi_pedestrian = if_else(is.na(ksi), NA, ksi_pedestrian),
		ksi_cyclist = if_else(is.na(ksi), NA, ksi_cyclist),
		ksi_other = if_else(is.na(ksi), NA, ksi_other)
	) %>%
	mutate( # fill in as year if unit is year
		ksi_time = case_when(
			tunit == "year" ~ ksi_year,
			.default = ksi_time
		),
		ksi_time_unit = tunit
	) %>%
	mutate( # assign ids and add time units
		id = factor(bike_id) %>% as.integer,
		bike_time_unit = tunit,
		ksi_time_unit = tunit
	) %>%
	mutate( # assign ksi time ids
		time = case_match(ksi_time_orig, !!!tid_map) %>% as.integer
	) %>%
	mutate( # assign cohort based on bike time ids
		cohort = case_match(bike_time_orig, !!!tid_map),
		cohort_install = case_match(bike_install_time_orig, !!!tid_map),
		cohort_upgrade1 = if_else(
			!bike_improve1,
			case_match(bike_upgrade1_time_orig, !!!tid_map),
			NA
		),
		cohort_upgrade2 = if_else(
			!bike_improve2,
			case_match(bike_upgrade2_time_orig, !!!tid_map),
			NA
		),
		cohort_improve1 = if_else(
			bike_improve1,
			case_match(bike_improve1_time_orig, !!!tid_map),
			NA
		),
		cohort_improve2 = if_else(
			bike_improve2,
			case_match(bike_improve2_time_orig, !!!tid_map),
			NA
		),
		cohort_remove1 = if_else(
			bike_remove1,
			case_match(bike_remove1_time_orig, !!!tid_map),
			NA
		),
		cohort_remove2 = if_else(
			bike_remove2,
			case_match(bike_remove2_time_orig, !!!tid_map),
			NA
		)
	) %>%
	mutate(across( # convert cohort to integers
		starts_with("cohort"),
		~ as.integer(.)
	)) %>%
	mutate( # fix cohort to min time id for times less than time range
		cohort = if_else(
			bike_year < min(tid$time_year),
			min(tid$time),
			cohort
		),
		cohort_install = if_else(
			bike_install_year < min(tid$time_year),
			min(tid$time),
			cohort_install
		),
		cohort_upgrade1 = if_else(
			!bike_improve1 & bike_upgrade1_year < min(tid$time_year),
			min(tid$time),
			cohort_upgrade1
		),
		cohort_upgrade2 = if_else(
			!bike_improve2 & bike_upgrade2_year < min(tid$time_year),
			min(tid$time),
			cohort_upgrade2
		),
		cohort_improve1 = if_else(
			bike_improve1 & bike_improve1_year < min(tid$time_year),
			min(tid$time),
			cohort_improve1
		),
		cohort_improve2 = if_else(
			bike_improve2 & bike_improve2_year < min(tid$time_year),
			min(tid$time),
			cohort_improve2
		),
		cohort_remove1 = if_else(
			bike_remove1 & bike_remove1_year < min(tid$time_year),
			min(tid$time),
			cohort_remove1
		),
		cohort_remove2 = if_else(
			bike_remove2 & bike_remove2_year < min(tid$time_year),
			min(tid$time),
			cohort_remove2
		)
	) %>%
	mutate( # assign cohort for infra types
		cohort_install_pl = if_else(
			bike_install_type %in% c("PL", "BUF"),
			cohort_install,
			NA
		),
		cohort_install_ct = if_else(
			bike_install_type == "PBL",
			cohort_install,
			NA
		),
		cohort_upgrade1_pl = if_else(
			bike_upgrade1_type %in% c("PL", "BUF"),
			cohort_upgrade1,
			NA
		),
		cohort_upgrade1_ct = if_else(
			bike_upgrade1_type == "PBL",
			cohort_upgrade1,
			NA
		),
		cohort_upgrade2_pl = if_else(
			bike_upgrade2_type %in% c("PL", "BUF"),
			cohort_upgrade2,
			NA
		),
		cohort_upgrade2_ct = if_else(
			bike_upgrade2_type == "PBL",
			cohort_upgrade2,
			NA
		),
		cohort_improve1_pl = if_else(
			bike_improve1_type %in% c("PL", "BUF"),
			cohort_improve1,
			NA
		),
		cohort_improve1_ct = if_else(
			bike_improve1_type == "PBL",
			cohort_improve1,
			NA
		),
		cohort_improve2_pl = if_else(
			bike_improve2_type %in% c("PL", "BUF"),
			cohort_improve2,
			NA
		),
		cohort_improve2_ct = if_else(
			bike_improve2_type == "PBL",
			cohort_improve2,
			NA
		),
		cohort_remove1_pl = if_else(
			bike_install_type %in% c("PL", "BUF") & bike_remove1,
			cohort_remove1,
			NA
		),
		cohort_remove1_ct = if_else(
			bike_install_type == "PBL" & bike_remove1,
			cohort_remove1,
			NA
		),
		cohort_remove2_pl = if_else(
			bike_upgrade1_type %in% c("PL", "BUF") & bike_remove2,
			cohort_remove2,
			NA
		),
		cohort_remove2_ct = if_else(
			bike_upgrade2_type == "PBL" & bike_remove2,
			cohort_remove2,
			NA
		),
		cohort_pl = coalesce(
			cohort_upgrade2_pl,
			cohort_upgrade1_pl,
			cohort_install_pl
		),
		cohort_ct = coalesce(
			cohort_upgrade2_ct,
			cohort_upgrade1_ct,
			cohort_install_ct
		)
	) %>%
	mutate( # assign post based on whether it is greater than bike time
		post = if_else(
			bike_remove,
			as.integer(
				time >= cohort |
				time >= cohort_install |
				time >= cohort_upgrade1 |
				time >= cohort_upgrade2
			) %>% replace_na(0),
			as.integer(time >= cohort) %>% replace_na(0)
		),
		post_install = as.integer(time >= cohort_install) %>% replace_na(0),
		post_install_pl = as.integer(time >= cohort_install_pl) %>% replace_na(0),
		post_install_ct = as.integer(time >= cohort_install_ct) %>% replace_na(0),
		post_upgrade1 = as.integer(time >= cohort_upgrade1) %>% replace_na(0),
		post_upgrade1_pl = as.integer(time >= cohort_upgrade1_pl) %>% replace_na(0),
		post_upgrade1_ct = as.integer(time >= cohort_upgrade1_ct) %>% replace_na(0),
		post_upgrade2 = as.integer(time >= cohort_upgrade2) %>% replace_na(0),
		post_upgrade2_pl = as.integer(time >= cohort_upgrade2_pl) %>% replace_na(0),
		post_upgrade2_ct = as.integer(time >= cohort_upgrade2_ct) %>% replace_na(0),
		post_improve1 = as.integer(time >= cohort_improve1) %>% replace_na(0),
		post_improve1_pl = as.integer(time >= cohort_improve1_pl) %>% replace_na(0),
		post_improve1_ct = as.integer(time >= cohort_improve1_ct) %>% replace_na(0),
		post_improve2 = as.integer(time >= cohort_improve2) %>% replace_na(0),
		post_improve2_pl = as.integer(time >= cohort_improve2_pl) %>% replace_na(0),
		post_improve2_ct = as.integer(time >= cohort_improve2_ct) %>% replace_na(0),
		post_remove1 = as.integer(
			time >= cohort_remove1 & (time < cohort_upgrade1 | time < cohort_improve1)
		) %>% replace_na(0),
		post_remove1_pl = as.integer(
			time >= cohort_remove1_pl & (time < cohort_upgrade1_pl | time < cohort_improve1_pl)
		) %>% replace_na(0),
		post_remove1_ct = as.integer(
			time >= cohort_remove1_ct & (time < cohort_upgrade1_ct | time < cohort_improve1_ct)
		) %>% replace_na(0),
		post_remove2 = as.integer(time >= cohort_remove2) %>% replace_na(0),
		post_remove2_pl = as.integer(time >= cohort_remove2_pl) %>% replace_na(0),
		post_remove2_ct = as.integer(time >= cohort_remove2_ct) %>% replace_na(0)
	) %>%
	mutate(across( # adjust post for removals, set 0 if post_remove is 1
		starts_with("post") & !starts_with("post_remove"),
		~ if_else( # invert post_remove and multiply
			bike_remove,
			. * (+!post_remove1) * (+!post_remove2),
			.
		)
	)) %>%
	mutate(across( # adjust post install to be 0 after removals
		starts_with("post_install"),
		~ if_else(
			bike_remove & (time >= bike_remove1 | time >= bike_remove2),
			0,
			.
		)
	)) %>%
	mutate( # add length in km
		bike_len_km = bike_len_meters / 1000,
		.after = bike_len_meters
	) %>%
	rowwise %>%
	mutate( # flag problematic segments
		flag_issue1 = if_else(
			bike_install_type %in% c("N", "None") |
				bike_upgrade1_type %in% c("N", "None") |
				bike_upgrade2_type %in% c("N", "None") |
				bike_improve1_type %in% c("N", "None") |
				bike_improve2_type %in% c("N", "None") |
				bike_remove1_type %in% c("N", "None") |
				bike_remove2_type %in% c("N", "None"),
			1,
			0
		)
	) %>%
	arrange(id, time) %>%
	select(
		starts_with("bike"),
		starts_with("ksi"),
		id,
		time,
		starts_with("post"),
		starts_with("cohort"),
		starts_with("flag"),
		everything()
	)

# Export model data and time ids to folder
model_data %>% write_csv("../data/recovr-eval-2024-11-12.csv", na = "")
```

### Details

```{r}

# Display rows and cols
cat(glue(
	"\nBefore\n",
	"\n* Rows: ", bike_ksi %>% nrow,
	"\n* Columns: ", bike_ksi %>% ncol,
	"\n\nAfter\n",
	"\n* Rows: ", model_data %>% nrow,
	"\n* Columns: ", model_data %>% ncol,
	"\n\nNew Columns (", model_data %>% ncol - bike_ksi %>% ncol, ")\n",
	paste0(
		"\n* ",
		colnames(model_data) %>%
			.[!. %in% colnames(bike_ksi)],
		collapse = ""
	)
))

```

### Preview

```{r}

# Display model data
model_data %>% head()

```

### Check

Perform data checks to ensure columns follow specifications.

This table identifies problems stated in the `check` column, while signifying if the check is passed in the `pass` column.

In addition, for row checks, the number of bikeways should be `0` and there should be no `ids` if all checks passed.


```{r}

# Check model data for row logic
model_data_check_list <- list(
	"Install time exists, but no cohort_install" = model_data %>%
		filter(
			!is.na(bike_install_time_orig) & is.na(cohort_install)
		),
	"Upgrade1 time exists, but no cohort_upgrade1" = model_data %>%
		filter(
			!is.na(bike_upgrade1_time_orig) & !bike_improve1 & is.na(cohort_upgrade1)
		),
	"Upgrade2 time exists, but no cohort_upgrade2" = model_data %>%
		filter(
			!is.na(bike_upgrade2_time_orig) & !bike_improve2 & is.na(cohort_upgrade2)
		),
	"Both upgrade1 and improve1 cohorts exist" = model_data %>%
		filter(
			!is.na(cohort_upgrade1) & !is.na(cohort_improve1)
		),
	"Both upgrade2 and improve2 cohorts exist" = model_data %>%
		filter(
			!is.na(cohort_upgrade2) & !is.na(cohort_improve2)
		),
	"Upgrade2 cohort exists but no upgrade1 or improve1 cohort" = model_data %>%
		filter(
			!is.na(cohort_upgrade2) & is.na(cohort_upgrade1) & is.na(cohort_improve1)
		),
	"Upgrade2 cohort exists but no install cohort" = model_data %>%
		filter(
			!is.na(cohort_upgrade2) & is.na(cohort_install)
		),
	"Upgrade1 cohort exists but no install cohort" = model_data %>%
		filter(
			!is.na(cohort_upgrade1) & is.na(cohort_install)
		),
	"Upgrade1 cohort exists but no install cohort" = model_data %>%
		filter(
			!is.na(cohort_upgrade1) & is.na(cohort_install)
		),
	"Install cohort exists but no PL or CT cohorts" = model_data %>%
		filter(
			!is.na(cohort_install) & is.na(cohort_install_pl) & is.na(cohort_install_ct)
		),
	"Upgrade1 cohort exists but no PL or CT cohorts" = model_data %>%
		filter(
			!is.na(cohort_upgrade1) & is.na(cohort_upgrade1_pl) & is.na(cohort_upgrade1_ct)
		),
	"Upgrade2 cohort exists but no PL or CT cohorts" = model_data %>%
		filter(
			!is.na(cohort_upgrade2) & is.na(cohort_upgrade2_pl) & is.na(cohort_upgrade2_ct)
		),
	"Cohort exists but no PL or CT cohorts" = model_data %>%
		filter(
			!is.na(cohort) & is.na(cohort_pl) & is.na(cohort_ct)
		),
	"Post install is 1 before cohort time" = model_data %>%
		filter(
			post_install == 1 & time < cohort_install
		),
	"Post upgrade1 is 1 before cohort time" = model_data %>%
		filter(
			post_upgrade1 == 1 & time < cohort_upgrade1
		),
	"Post upgrade2 is 1 before cohort time" = model_data %>%
		filter(
			post_upgrade2 == 1 & time < cohort_upgrade2
		),
	"Post is 1 before cohort time if there is no removal" = model_data %>%
		filter(
			post == 1 & time < cohort & !bike_remove
		),
	"Post install is 0 after cohort time if there is no removal" = model_data %>%
		filter(
			post_install == 0 & time >= cohort_install & !bike_remove
		),
	"Post upgrade1 is 0 after cohort time" = model_data %>%
		filter(
			post_upgrade1 == 0 & time >= cohort_upgrade1
		),
	"Post upgrade2 is 0 after cohort time if there is no removal" = model_data %>%
		filter(
			post_upgrade2 == 0 & time >= cohort_upgrade2 & !bike_remove
		),
	"Post is 0 after cohort time" = model_data %>%
		filter(
			post == 0 & time >= cohort
		),
	"KSI is outside data range" = model_data %>%
		filter(
			!is.na(ksi) & ksi_year < ksi_year_min & ksi_year > ksi_year_max
		),
	"Driver KSI is outside data range" = model_data %>%
		filter(
			!is.na(ksi_driver) & ksi_year < ksi_year_min & ksi_year > ksi_year_max
		),
	"Pedestrian KSI is outside data range" = model_data %>%
		filter(
			!is.na(ksi_pedestrian) & ksi_year < ksi_year_min & ksi_year > ksi_year_max
		),
	"Cyclist KSI is outside data range" = model_data %>%
		filter(
			!is.na(ksi_cyclist) & ksi_year < ksi_year_min & ksi_year > ksi_year_max
		),
	"Other KSI is outside data range" = model_data %>%
		filter(
			!is.na(ksi_other) & ksi_year < ksi_year_min & ksi_year > ksi_year_max
		),
	"Road user KSI does not add up to all KSI" = model_data %>%
		filter(
			ksi != sum(ksi_driver, ksi_pedestrian, ksi_cyclist, ksi_other)
		),
	"Post is not 0 during first removal time" = model_data %>%
		filter(
			post != 0 &
			time >= cohort_remove1 &
			(time < cohort_upgrade1 | time < cohort_improve1)
		),
	"Post is not 0 during second removal time" = model_data %>%
		filter(
			post != 0 & time >= cohort_remove2
		),
	"Post install is not 0 after first removal time" = model_data %>%
		filter(
			post_install != 0 &
			time >= cohort_remove1
		),
	"Post upgrade2 is not 0 during first removal time" = model_data %>%
		filter(
			post_upgrade2 != 0 & bike_remove1
		),
	"Post install is not 0 during second removal time" = model_data %>%
		filter(
			post_install != 0 & time >= cohort_remove2
		),
	"Post upgrade1 is not 0 during second removal time" = model_data %>%
		filter(
			post_upgrade1 != 0 & time >= cohort_remove2
		),
	"Post upgrade2 is 1 during second removal time" = model_data %>%
		filter(
			post_upgrade2 != 0 & time >= cohort_remove2
		),
	"Single dist road user KSI does not add up to all KSI" = model_data %>%
		filter((if_any(
			matches("ksi_\\d+m$"),
			~.x != sum(
				get(str_replace(cur_column(), "ksi_", "ksi_driver_")),
				get(str_replace(cur_column(), "ksi_", "ksi_pedestrian_")),
				get(str_replace(cur_column(), "ksi_", "ksi_cyclist_")),
				get(str_replace(cur_column(), "ksi_", "ksi_other_")),
				na.rm = T
			)
		))),
	"Additive dist road user KSI does not add up to all KSI" = model_data %>%
		filter((if_any(
			matches("ksi_\\d+to\\d+m$"),
			~.x != sum(
				get(str_replace(cur_column(), "ksi_", "ksi_driver_")),
				get(str_replace(cur_column(), "ksi_", "ksi_pedestrian_")),
				get(str_replace(cur_column(), "ksi_", "ksi_cyclist_")),
				get(str_replace(cur_column(), "ksi_", "ksi_other_")),
				na.rm = T
			)
		)))
)

# Create df template of checks
model_data_check <- data.frame(
	check = character(),
	check_type = character(),
	bikeways = integer(),
	ids = character()
)

# Add row checks to fill template
for (check in names(model_data_check_list)) {
	check_data <- model_data_check_list[[check]]
	check_ids <- check_data %>% pull(id) %>% unique
	model_data_check <- model_data_check %>%
		add_row(
			check = check,
			check_type = "row",
			bikeways =  check_ids %>% length,
			ids = check_ids %>% paste0(., collapse = ",")
		)
}

# Add pass to row checks
model_data_check <- model_data_check %>%
	mutate(pass = if_else(bikeways == 0, T, F))

# Add column checks
model_data_check <- model_data_check %>%
	add_row(
		check = "Sum of all KSIs is not equal to the total KSIs available",
		check_type = "column",
		pass = sum(model_data$ksi, na.rm = T) == (
			sjoin %>%
				filter(!is.na(id)) %>%
				pull(ksi_id) %>%
				unique %>%
				length
		)
	) %>%
	add_row(
		check = "Sum of all single dist KSIs is not equal to the total KSIs available",
		check_type = "column",
		pass = all(sapply(
			bike_sjoin_cols %>%
				unique %>%
				.[!str_detect(., "to")],
			function(x) {
			    sum(model_data[[glue("ksi_{x}m")]], na.rm = T) == (
			        sjoin %>%
			            filter(!is.na(id) & `_sjoin_meters` <= as.numeric(x)) %>%
			            pull(ksi_id) %>%
			            unique %>%
			            length
			    )
		}))
	) %>%
	add_row(
		check = "Sum of all additive dist KSIs is not equal to the total KSIs available",
		check_type = "column",
		pass = all(sapply(
			bike_sjoin_cols %>%
				unique %>%
				.[str_detect(., "to")],
			function(x) {
			    sum(model_data[[glue("ksi_{x}m")]], na.rm = T) == (
			        sjoin %>%
			            filter(
			            	!is.na(id) &
			            	`_sjoin_meters` >= as.numeric(
			            		str_split_1(x %>% unique, "to")[1]
			            	) &
			            	`_sjoin_meters` <= as.numeric(
			            		str_split_1(x %>% unique, "to")[2]
			            	)
			            ) %>%
			            pull(ksi_id) %>%
			            unique %>%
			            length
			    )
		}))
	)

# Preview and save data check
model_data_check
model_data_check %>% write_csv("../data/recovr-eval-check-2024-11-12.csv", na = "")

```

The next table identifies problems per column and simply 

## Flow Chart {.tabset}

```{r}

# Func to calc km
calc_total_km <- function(df, places = 0) {
	out <- round(
		df %>%
			st_length %>%
			as.numeric %>%
			sum(., na.rm = T) / 1000,
		places
	)
	return(out)
}

# Calculate vancbike vars
vancbike_stats <- list(
	raw = vancbike_raw %>% nrow,
	verify = bike_verify %>% filter(city == "vancouver") %>% nrow,
	itypes = bike_itypes %>% filter(city == "vancouver") %>% nrow,
	p2010 = bike_p2010 %>% filter(city == "vancouver") %>% nrow,
	tfilter = bike_tfilter %>% filter(city == "vancouver") %>% nrow,
	sjoin = sjoin %>% filter(ksi_city == "vancouver" & !is.na(id) & `_sjoin_meters` <= 25) %>% pull(ksi_id) %>% unique %>% length,
	raw_km = calc_total_km(vancbike_raw),
	verify_km = calc_total_km(bike_verify %>% filter(city == "vancouver")),
	itypes_km = calc_total_km(bike_itypes %>% filter(city == "vancouver")),
	p2010_km = calc_total_km(bike_p2010 %>% filter(city == "vancouver")),
	tfilter_km = calc_total_km(bike_tfilter %>% filter(city == "vancouver")),
	years = vancbike_raw$install_year %>% range(na.rm = T) %>% paste0(., collapse = "-")
)

# Calculate vancksi vars
vancksi_stats <- list(
	raw = ksi_combine %>% filter(ksi_city == "vancouver") %>% nrow %>% format(big.mark = ","),
	coords = ksi_coords %>% filter(ksi_city == "vancouver") %>% nrow %>% format(big.mark = ","),
	injury = ksi_injury %>% filter(ksi_city == "vancouver") %>% nrow %>% format(big.mark = ","),
	y2009to2023 = ksi_y2009to2023 %>% filter(ksi_city == "vancouver") %>% nrow %>% format(big.mark = ","),
	years = vancksi %>% mutate(x = year(ksi_date)) %>% pull(x) %>% range(na.rm = T) %>% paste0(., collapse = "-")
)

# Calculate calgbike vars
calgbike_stats <- list(
	raw = calgbike_raw %>% nrow,
	verify = bike_verify %>% filter(city == "calgary") %>% nrow,
	itypes = bike_itypes %>% filter(city == "calgary") %>% nrow,
	p2010 = bike_p2010 %>% filter(city == "calgary") %>% nrow,
	tfilter = bike_tfilter %>% filter(city == "calgary") %>% nrow,
	sjoin = sjoin  %>% filter(ksi_city == "calgary" & !is.na(id) & `_sjoin_meters` <= 25) %>% pull(ksi_id) %>% unique %>% length,
	raw_km = calc_total_km(calgbike_raw),
	verify_km = calc_total_km(bike_verify %>% filter(city == "calgary")),
	itypes_km = calc_total_km(bike_itypes %>% filter(city == "calgary")),
	p2010_km = calc_total_km(bike_p2010 %>% filter(city == "calgary")),
	tfilter_km = calc_total_km(bike_tfilter %>% filter(city == "calgary")),
	years = calgbike_raw$install_year %>% range(na.rm = T) %>% paste0(., collapse = "-")
)

# Calculate calgksi vars
calgksi_stats <- list(
	raw = ksi_combine %>% filter(ksi_city == "calgary") %>% nrow %>% format(big.mark = ","),
	coords = ksi_coords %>% filter(ksi_city == "calgary") %>% nrow %>% format(big.mark = ","),
	injury = ksi_injury %>% filter(ksi_city == "calgary") %>% nrow %>% format(big.mark = ","),
	y2009to2023 = ksi_y2009to2023 %>% filter(ksi_city == "calgary") %>% nrow %>% format(big.mark = ","),
	years = calgksi %>% mutate(x = year(ksi_date)) %>% pull(x) %>% range(na.rm = T) %>% paste0(., collapse = "-")
)

# Calculate toronbike n vars
toronbike_stats <- list(
	raw = toronbike_raw %>% nrow,
	verify = bike_verify %>% filter(city == "toronto") %>% nrow,
	itypes = bike_itypes %>% filter(city == "toronto") %>% nrow,
	p2010 = bike_p2010 %>% filter(city == "toronto") %>% nrow,
	tfilter = bike_tfilter %>% filter(city == "toronto") %>% nrow,
	sjoin = sjoin %>% filter(ksi_city == "toronto" & !is.na(id) & `_sjoin_meters` <= 25) %>% pull(ksi_id) %>% unique %>% length,
	raw_km = calc_total_km(toronbike_raw),
	verify_km = calc_total_km(bike_verify %>% filter(city == "toronto")),
	itypes_km = calc_total_km(bike_itypes %>% filter(city == "toronto")),
	p2010_km = calc_total_km(bike_p2010 %>% filter(city == "toronto")),
	tfilter_km = calc_total_km(bike_tfilter %>% filter(city == "toronto")),
	years = toronbike_raw$install_year %>% range(na.rm = T) %>% paste0(., collapse = "-")
)

# Calculate toronksi n vars
toronksi_stats <- list(
	raw = ksi_combine %>% filter(ksi_city == "toronto") %>% nrow %>% format(big.mark = ","),
	coords = ksi_coords %>% filter(ksi_city == "toronto") %>% nrow %>% format(big.mark = ","),
	injury = ksi_injury %>% filter(ksi_city == "toronto") %>% nrow %>% format(big.mark = ","),
	y2009to2023 = ksi_y2009to2023 %>% filter(ksi_city == "toronto") %>% nrow %>% format(big.mark = ","),
	years = toronksi %>% mutate(x = year(ksi_date)) %>% pull(x) %>% range(na.rm = T) %>% paste0(., collapse = "-")
)

# Other vars for flow chart
tunit_title <- tunit %>% str_to_title

# Create flow chart
fig_flowchart <- grViz(glue('

digraph {
	
	// Settings
	layout=neato
	splines=ortho
	node [shape="box", width=2.75, height=1.75, margin=0.1]
	
	// Raw bikeways
	bike_raw[
		width=2,
		shape=cylinder,
		label=<
			<br/><b>Bikeways*</b><br/><br/>
			Vancouver: {{vancbike_stats$raw_km}} km (n={{vancbike_stats$raw}}) <br/>
			Calgary: {{calgbike_stats$raw_km}} km (n={{calgbike_stats$raw}})<br/>
			Toronto: {{toronbike_stats$raw_km}} km (n={{toronbike_stats$raw}})
		>,
		pos="0,0!"
	]
	
	// Verified bikeways with PL and CT only
	bike_itypes[
		label=<
			<b>Verified Bikeways and Painted<br/>Lanes/Cycle Tracks Only</b><br/><br/>
			Vancouver: {{vancbike_stats$itypes_km}} km (n={{vancbike_stats$itypes}}) <br/>
			Calgary: {{calgbike_stats$itypes_km}} km (n={{calgbike_stats$itypes}})<br/>
			Toronto: {{toronbike_stats$itypes_km}} km (n={{toronbike_stats$itypes}})
		>,
		pos="3,0!"
	]
	
	// Post-2010 bikeways with time
	bike_tfilter[
		label=<
			<b>Post-2010 Installs<br/>
			or Upgrades with {{tunit_title}}s Only</b><br/><br/>
			Vancouver: {{vancbike_stats$tfilter_km}} km (n={{vancbike_stats$tfilter}}) <br/>
			Calgary: {{calgbike_stats$tfilter_km}} km (n={{calgbike_stats$tfilter}})<br/>
			Toronto: {{toronbike_stats$tfilter_km}} km (n={{toronbike_stats$tfilter}})
		>,
		pos="6,0!"
	]
	
	// Raw KSI
	ksi_raw[
		width=2,
		shape=cylinder,
		label=<
			<br/><b>KSI**</b><br/><br/>
			Vancouver: {{vancksi_stats$raw}} KSI<br/>
			Calgary: {{calgksi_stats$raw}} KSI<br/>
			Toronto: {{toronksi_stats$raw}} KSI
		>,
		pos="0,-2.15!"
	]
	
	// KSI with coordinates
	ksi_coords[
		label=<
			<b>With Coordinates</b><br/><br/>
			Vancouver: {{vancksi_stats$coords}} KSI<br/>
			Calgary: {{calgksi_stats$coords}} KSI<br/>
			Toronto: {{toronksi_stats$coords}} KSI
		>,
		pos="3,-2.15!"
	]
	
	// KSI with fatal or serious injury only
	ksi_injury[
		label=<
			<b>Fatal or Serious<br/>Injuries Only</b><br/><br/>
			Vancouver: {{vancksi_stats$injury}} KSI<br/>
			Calgary: {{calgksi_stats$injury}} KSI<br/>
			Toronto: {{toronksi_stats$injury}} KSI
		>,
		pos="6,-2.15!"
	]
	
	// Post-2010 KSI
	ksi_y2009to2023[
		label=<
			<b>From 2009 to 2023</b><br/><br/>
			Vancouver: {{vancksi_stats$y2009to2023}} KSI<br/>
			Calgary: {{calgksi_stats$y2009to2023}} KSI<br/>
			Toronto: {{toronksi_stats$y2009to2023}} KSI
		>,
		pos="9,-2.15!"
	]
	
	// Spatial Joined KSI
	ksi_sjoin[
		label=<
			<b>KSI Within 25 Meters of<br/>
			Merged Bikeways</b><br/><br/>
			Vancouver: {{vancbike_stats$sjoin}} KSI (n={{vancbike_stats$tfilter}}) <br/>
			Calgary: {{calgbike_stats$sjoin}} KSI (n={{calgbike_stats$tfilter}})<br/>
			Toronto: {{toronbike_stats$sjoin}} KSI (n={{toronbike_stats$tfilter}})
		>,
		pos="9,0!"
	]
	
	// Footer
	foot[
		shape="none",
		fontsize="10",
		height=0.65,
		width=1,
		labeljust="r",
		label="*Bikeway Data Year Ranges: Vancouver ({{vancbike_stats$years}}), Calgary ({{calgbike_stats$years}}), Toronto ({{toronbike_stats$years}})\n**KSI Data Year Ranges: Vancouver ({{vancksi_stats$years}}), Calgary ({{calgksi_stats$years}}), Toronto ({{toronksi_stats$years}})",
		pos="5,-3.35!"
	]
	
	// Bikeway process
	bike_raw -> bike_itypes -> bike_tfilter -> ksi_sjoin
	
	// KSI process
	ksi_raw -> ksi_coords -> ksi_injury -> ksi_y2009to2023 -> ksi_sjoin
}

', .open = "{{", .close = "}}"))

# Export flowchart
fig_flowchart %>%
    export_svg %>%
    charToRaw %>%
    rsvg_png(
    	"../figures/fig-methods.png",
    	width = 1920
    )

# Display flowchart
fig_flowchart

```
