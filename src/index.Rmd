---
title: "Cycling Interventions Evaluation"
subtitle: "R Code"
author:
- "Richard Wen richard.wen@utoronto.ca"
- "Brice Batomen brice.kuimi@utoronto.ca"
- "Linda Rothman linda.rothman@torontomu.ca"
- "Andrew Howard andrew.howard@sickkids.ca"
date: "`r format(Sys.time(), '%B %d, %Y')`"
knit: |
    (function(input_rmd, ...) {
    rmarkdown::render(
        input_rmd,
        rmarkdown::html_document(
            toc = TRUE,
            toc_float = TRUE,
            highlight = "zenburn",
            code_folding = "hide",
            df_print = "paged",
            self_contained = FALSE
        ),
        output_dir = "../docs",
        output_file = "index", ...)
    })
---

```{r include = FALSE, echo = FALSE}
knitr::opts_chunk$set(
	warning = FALSE,
	message = FALSE
)
```

# Installation

1.  Install [R](https://www.r-project.org/)
2.  Install [RTools](https://cran.r-project.org/) if you are on Windows
3.  Install [RStudio](https://posit.co/download/rstudio-desktop/)

For more details, see [Software and Package Versions](#software-and-package-versions).

# Running This Code

1.  Ensure the installation steps above are completed
2.  Download a zip of the code and data [here](https://github.com/rrwen/recovr-eval/archive/refs/heads/main.zip) and unzip it
    - Code Repository: [github.com/rrwen/recovr-eval](https://github.com/rrwen/recovr-eval)
3.  In RStudio, open the [src/src.Rproj](https://github.com/rrwen/recovr-eval/blob/main/src/src.Rproj) file
4.  Then, open the [src/index.Rmd](https://github.com/rrwen/recovr-eval/blob/main/src/index.Rmd) file
5.  In RStudio:
    - Run all code: Click the `Run` drop down (top right of the code pane) and click `Run All`
    - Generate HTML version: Click `knit` (top left of code pane) and a file will be generated in `docs/index.html`

# Libraries

Install R packages if needed.

```{r, results = FALSE}

# Required packages
required_packages <- c(
	"rmarkdown",
	"bookdown",
	"knitr",
	"tidyverse",
	"purrr",
	"glue",
	"lubridate",
	"scales",
	"patchwork",
	"DiagrammeR",
	"DiagrammeRsvg",
	"webshot2",
	"magick",
	"rsvg",
	"sf",
	"tmap",
	"ggspatial",
	"prettymapr",
	"units",
	"leaflet",
	"leaflet.extras",
	"igraph"
)

# Try to install packages if not installed
default_options <- options()
tryCatch(
	{
		# Disable interactivity
		options(install.packages.compile.from.source = "always")
		
		# Install package if not installed
		for (package in required_packages) {
			is_package_installed <- require(package, character.only = TRUE)
			if (!is_package_installed) {
				cat(paste0("Installing package: ", package, "\n"))
				install.packages(package)
			} else {
				cat(paste0("Package already installed: ", package, "\n"))
			}
		}
	},
	error = function(cond) {
		stop(cond)
	},
	finally = {
		options(default_options) # reset interactivity
	}
)
```

Load R libraries.

```{r}
library(DiagrammeR)
library(ggplot2)
library(ggspatial)
library(glue)
library(igraph)
library(leaflet)
library(leaflet.extras)
library(lubridate)
library(patchwork)
library(sf)
library(tidyverse)
library(tmap)
```

# Data

Read data from the `data` folder.

```{r}
ddesc <- read_csv("../data/data.csv")
ddesc
```

## Vancouver Bikeways {.tabset}

`r ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(notes)`

```{r}

# Read data
vancbike_raw <- read_sf("../data/vancouver-bikeways-2024-06-02.geojson")

# Get download date
vancbike_dldate <- ddesc %>% filter(
	file == "vancouver-bikeways-2024-06-02.geojson"
) %>% pull(download_date)
```

### Map

Only the first 1000 records are shown.

```{r}
tmap_mode("view")
tm_shape(vancbike_raw %>% head(1000)) +
    tm_lines(
    	col = "#336699",
    	border.col = "white",
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(vancbike_raw)`
* Rows: `r nrow(vancbike_raw)`

```{r}
vancbike_raw %>% as_tibble
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
vancbike_ddict <- read_csv("../data/vancouver-bikeways-2024-06-02-datadict.csv")
vancbike_ddict
```

### Details

```{r}
print(vancbike_raw)
```

### Files

The data files are available below:

- [vancouver-bikeways-2024-06-02.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/vancouver-bikeways-2024-06-02.geojson)
- [vancouver-bikeways-2024-06-02-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/vancouver-bikeways-2024-06-02-datadict.csv)

## Calgary Bikeways {.tabset}

`r ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(notes)`

```{r}

# Read data
calgbike_raw <- read_sf("../data/calgary-bikeways-2024-06-05.geojson")

# Get download date
calgbike_dldate <- ddesc %>% filter(
	file == "calgary-bikeways-2024-06-05.geojson"
) %>% pull(download_date)
```

### Map

Only the first 1000 records are shown.

```{r}
tmap_mode("view")
tm_shape(calgbike_raw %>% head(1000)) +
    tm_lines(
    	col = "#336699",
    	border.col = "white",
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(calgbike_raw)`
* Rows: `r nrow(calgbike_raw)`

```{r}
calgbike_raw %>% as_tibble
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
calgbike_ddict <- read_csv("../data/calgary-bikeways-2024-06-05-datadict.csv")
calgbike_ddict
```

### Details

```{r}
print(calgbike_raw)
```

### Files

The data files are available below:

- [calgary-bikeways-2024-06-05.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/calgary-bikeways-2024-06-05.geojson)
- [calgary-bikeways-2024-06-05-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/calgary-bikeways-2024-06-05-datadict.csv)

## Toronto Bikeways {.tabset}

`r ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(notes)`

```{r}

# Read data
toronbike_raw <- read_sf("../data/toronto-bikeways-2024-06-02.geojson")

# Get download date
toronbike_dldate <- ddesc %>% filter(
	file == "toronto-bikeways-2024-06-02.geojson"
) %>% pull(download_date)
```

### Map

Only the first 1000 records are shown.

```{r}
tmap_mode("view")
tm_shape(toronbike_raw %>% head(1000)) +
    tm_lines(
    	col = "#336699",
    	border.col = "white",
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(toronbike_raw)`
* Rows: `r nrow(toronbike_raw)`

```{r}
toronbike_raw %>% as_tibble
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
toronbike_ddict <- read_csv("../data/toronto-bikeways-2024-06-02-datadict.csv")
toronbike_ddict
```

### Details

```{r}
print(toronbike_raw)
```

### Files

The data files are available below:

- [toronto-bikeways-2024-06-02.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-bikeways-2024-06-02.geojson)
- [toronto-bikeways-2024-06-02-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-bikeways-2024-06-02-datadict.csv)

## Verified Dates {.tabset}

`r ddesc %>% filter(file == "verify-dates-2024-06-12.csv") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "verify-dates-2024-06-12.csv") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "verify-dates-2024-06-12.csv") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "verify-dates-2024-06-12.csv") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "verify-dates-2024-06-12.csv") %>% pull(notes)`

```{r}

# Read data
vdates_raw <- read_csv("../data/verify-dates-2024-06-12.csv")

# Get download date
vdates_dldate <- ddesc %>% filter(
	file == "verify-dates-2024-06-12.csv"
) %>% pull(download_date)
```

### Data

* Columns: `r ncol(vdates_raw)`
* Rows: `r nrow(vdates_raw)`

```{r}
vdates_raw
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
vdates_ddict <- read_csv("../data/verify-dates-2024-06-12-datadict.csv")
vdates_ddict
```

### Files

The data files are available below:

- [verify-dates-2024-06-12.csv](https://github.com/rrwen/recovr-eval/blob/main/data/verify-dates-2024-06-12.csv)
- [verify-dates-2024-06-12-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/verify-dates-2024-06-12-datadict.csv)

## Toronto KSI {.tabset}

`r ddesc %>% filter(file == "toronto-ksi-2024-06-13.csv") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "toronto-ksi-2024-06-13.csv") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "toronto-ksi-2024-06-13.csv") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "toronto-ksi-2024-06-13.csv") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "toronto-ksi-2024-06-13.csv") %>% pull(notes)`

```{r}

# Read data
toronksi_raw <- read_sf(
	"../data/toronto-ksi-2024-06-13.csv",
	options = c(
		"X_POSSIBLE_NAMES=LONGITUDE",
		"Y_POSSIBLE_NAMES=LATITUDE"
	),
	crs = 4326
)

# Get download date
toronksi_dldate <- ddesc %>% filter(
	file == "toronto-ksi-2024-06-13.csv"
) %>% pull(download_date)
```

### Map

**Note**: Due to the large number of records, only the latest year of `r year(max(toronksi_raw$DATE))` is displayed (n = `r toronksi_raw %>% filter(year(DATE) == max(year(DATE))) %>% nrow`).

```{r}
tmap_mode("view")
tm_shape(toronksi_raw %>% filter(year(DATE) == max(year(DATE)))) +
    tm_dots(
    	col = "ACCLASS",
    	clustering = TRUE,
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(toronksi_raw)`
* Rows: `r nrow(toronksi_raw)`

```{r}
toronksi_raw %>% as_tibble()
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
ksi_ddict <- read_csv("../data/toronto-ksi-2024-06-13-datadict.csv")
ksi_ddict
```

### Details

```{r}
print(toronksi_raw)
```

### Files

The data files are available below:

- [toronto-ksi-2024-06-13.csv](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-ksi-2024-06-13.csv)
- [toronto-ksi-2024-06-13-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-ksi-2024-06-13-datadict.csv)

# Cleaning

## Combine Bikeways {.tabset}

Combine bikeway data across all cities.

```{r}

# List of city bikeway data
bike_list <- list(
	vancouver = vancbike_raw,
	calgary = calgbike_raw %>%
		mutate(no_verify_install_type = NA),
	toronto = toronbike_raw %>%
		mutate(no_verify_install_type = NA)
)

# Get common columns across all city bikeways
bike_cols <- bike_list %>%
	map(colnames) %>%
	reduce(intersect)

# Combine bikeway data across cities
bike_raw <- names(bike_list) %>%
	map(function(city) {
		bike_list[[city]] %>%
			select(
				all_of(bike_cols)
			) %>%
			mutate(
				city = factor(city, levels = names(bike_list)),
				.before = 1
			)
	}) %>%
	reduce(add_row)

# Display combined bikeway data
bike_raw %>% as_tibble %>% head

```

## Combine KSI

Combine KSI data across cities and standardize columns.

**Note**: Only Toronto KSI is included for now.

```{r}
ksi <- toronksi_raw %>%
	mutate(
		ksi_city = "toronto",
		ksi_id = INDEX,
		ksi_date = DATE
	)

# Display combined bikeway data
ksi %>% as_tibble %>% head
```

## Remove Empty Bikeway Types

Removes empty types from `verify_install_type` with `None`, `NA`, and `N`.

```{r}

# Remove none or na bike types
bike <- bike_raw %>%
	filter(!verify_install_type %in% c("None", "N", NA))

# Display counts
bike %>%
	as_tibble %>%
	select(
		city,
		id,
		verify_install_type
	) %>%
	group_by(city, verify_install_type) %>%
	count
```

## Add Bikeway Dates

Join ambiguous verified install/upgrade dates (e.g. Jan 1/2022, 2022/02, Fall 2020) to manually cleaned dates with structured time units (e.g. days, months, quarters, semesters, ranges) and date formats (e.g. 2022-01-01, 2022-02-01).

The following cleaned structured date columns will be added to bikeways:

```{r}

# Get column names from verified dates
vdates_cols <- tidyr::crossing(c("_install_", "_upgrade1_", "_upgrade2_"), colnames(vdates_raw)) %>%
    filter(.[[2]] != "verify_date_raw") %>%
    mutate(column = paste0(.[[1]], .[[2]])) %>%
    pull(column)
    
```

`r vdates_cols %>% paste0("\n * ", ., collapse = "")`

```{r}

# Join clean dates to include structured date formats
bike <- bike %>%
	left_join( # install dates
		vdates_raw %>%
			rename_with(~ paste0("_install_", .x)),
		by = join_by(verify_install_date == `_install_verify_date_raw`)
	) %>%
	left_join( # upgrade1 dates
		vdates_raw %>%
			rename_with(~ paste0("_upgrade1_", .x)),
		by = join_by(verify_upgrade1_date == `_upgrade1_verify_date_raw`)
	) %>%
	left_join( # upgrade2 dates
		vdates_raw %>%
			rename_with(~ paste0("_upgrade2_", .x)),
		by = join_by(verify_upgrade2_date == `_upgrade2_verify_date_raw`)
	)

# Display clean dates cols
bike %>%
	as_tibble %>%
	select(all_of(vdates_cols)) %>%
	arrange(`_install_verify_date_type`)

```

## Add Time Units {.tabset}

Add the following time unit columns for installs/upgrades in bikeways and for each ksi record:

* `_time_month`: which month (1, 2, 3 ... 12) a bikeway had a verified installation/upgrade or ksi record
* `_time_quarter`: which quarter (1, 2, 3, 4) of the year a bikeway had a verified installation/upgrade or ksi record
* `_time_third`: which third (1, 2, 3) of the year a bikeway had a verified installation/upgrade or ksi record
* `_time_half`: which half (1, 2) of the year a bikeway had a verified installation/upgrade or ksi record
* `_time_semester`: which semester (1, 2) of the year a bikeway had a verified installation/upgrade or ksi record, where:
	* `1`: represents November (this year) to April of next year
	* `2`: represents May to October of next year
* `_time_year`: standardized year column that bikeway had verified installation/upgrade or ksi record
* `_time_..._group`: grouped columns of the above defining the time units in textual format
* KSI records will follow the same patterns above except prefixed with `_ksi` as well

**Note**: Date ranges that fall between months, quarters, thirds, or halves of the year were excluded from being classified as any of the time units (e.g. March 31 to April 15 will be excluded as it does not fall within either the 1st or 2nd quarter of the year).

```{r}

#' Add Time Units to Data Frame
#'
#' This function takes a data frame and adds new columns representing various time units such as month, quarter, third, half, and semester. These columns are derived from a date column or if the time unit is more than day, then additiona start and end date columns
#'
#' @param df A data frame that contains the columns `verify_date`, `verify_date_type`, `verify_date_start`, and `verify_date_end`.
#' @param date_col Name of the date column to use
#' @param start_col Name of the start date column to use
#' @param end_col Name of the end date column to use
#' @param type_col Name of the date type column to use (e.g. month, day, year, etc)
#' @param prefix Additional text to add to the output column names
#' @param assign_semester Whether to assign intervals between semesters to be in the semester with the max duration that the interval falls in. When durations are equal, semester 2 will be chosen.
#'
#' @return A data frame with additional columns (without `prefix`):
#' \describe{
#'   \item{`_time_month`}{Numeric representation of the month (1-12).}
#'   \item{`_time_month_group`}{Unique time group for month.}
#'   \item{`_time_quarter`}{Quarter of the year (1-4).}
#'   \item{`_time_quarter_group`}{Unique time group for quarter.}
#'   \item{`_time_third`}{Third of the year (1-3).}
#'   \item{`_time_third_group`}{Unique time group for third.}
#'   \item{`_time_half`}{Half of the year (1-2).}
#'   \item{`_time_half_group`}{Unique time group for half.}
#'   \item{`_time_semester`}{Custom semester (1 for May-Oct, 2 for Nov-Apr).}
#'   \item{`_assign_semester`}{Whether the date was assigned since it did not fall between either semester 1 or 2.}
#'   \item{`_assign_semester_1_days`}{Number of days that the date is in semester 1 if `assign_semester` is `TRUE`.}
#'   \item{`_assign_semester_2_days`}{Number of days that the date is in semester 2 if `assign_semester` is `TRUE`.}
#'   \item{`_time_semester_group`}{Unique time group for semester.}
#'   \item{`_time_year`}{4-digit year.}
#' }
#'
#' @examples
#' \dontrun{
#' df <- data.frame(
#'   verify_date = as.Date(c("2021-01-15", "2021-06-20", "2021-09-10")),
#'   verify_date_type = c("day", "month", "day"),
#'   verify_date_start = as.Date(c("2021-01-01", "2021-06-01", "2021-09-01")),
#'   verify_date_end = as.Date(c("2021-01-31", "2021-06-30", "2021-09-30"))
#' )
#' result <- add_time_units(df)
#' print(result)
#' }
#'
#' @import dplyr
#' @importFrom lubridate month year
#' @export
add_time_units <- function(
	df,
	date_col = "_install_verify_date",
	start_col = "_install_verify_date_start",
	end_col = "_install_verify_date_end",
	type_col = "_install_verify_date_type",
	year_col = "verify_install_year",
	prefix = NULL,
	assign_semester = T
) {
	
	# Code time units
	out <- df %>%
		mutate( # rename req cols
			`_date` = .data[[date_col]],
			`_start` = .data[[start_col]],
			`_end` = .data[[end_col]],
			`_type` = .data[[type_col]],
			`_year` = .data[[year_col]]
		) %>%
		mutate( # add time units
			
			# Months (monthly)
			`_time_month` = case_when(
				`_type` %in% c("day", "month") ~ month(`_date`, label = T, abbr = F)
			),
			`_time_month` = as.numeric(`_time_month`),
			
			# Quarters (quarterly)
			`_time_quarter` = case_when(
				month(`_date`) %in% 1:3 |
				(
					month(`_start`) %in% 1:3 &
					month(`_end`) %in% 1:3 &
					year(`_start`) == year(`_end`)
				) ~ 1,
				month(`_date`) %in% 4:6 |
				(
					month(`_start`) %in% 4:6 &
					month(`_end`) %in% 4:6 &
					year(`_start`) == year(`_end`)
				) ~ 2,
				month(`_date`) %in% 7:9 |
				(
					month(`_start`) %in% 7:9 &
					month(`_end`) %in% 7:9 &
					year(`_start`) == year(`_end`)
				) ~ 3,
				month(`_date`) %in% 10:12 |
				(
					month(`_start`) %in% 10:12 &
					month(`_end`) %in% 10:12 &
					year(`_start`) == year(`_end`)
				) ~ 4
			),
			
			# Thirds (triyearly)
			`_time_third` = case_when(
				month(`_date`) %in% 1:4 |
				(
					month(`_start`) %in% 1:4 &
					month(`_end`) %in% 1:4 &
					year(`_start`) == year(`_end`)
				) ~ 1, # Fall
				month(`_date`) %in% 5:8 |
				(
					month(`_start`) %in% 5:8 &
					month(`_end`) %in% 5:8 &
					year(`_start`) == year(`_end`)
				) ~ 2, # Winter
				month(`_date`) %in% 9:12 |
				(
					month(`_start`) %in% 9:12 &
					month(`_end`) %in% 9:12 &
					year(`_start`) == year(`_end`)
				) ~ 3 # Spring/Summer
			),
			
			# Halves (biyearly)
			`_time_half` = case_when(
				month(`_date`) %in% 1:6 |
				(
					month(`_start`) %in% 1:6 &
					month(`_end`) %in% 1:6 &
					year(`_start`) == year(`_end`)
				) ~ 1,
				month(`_date`) %in% 7:12 |
				(
					month(`_start`) %in% 7:12 &
					month(`_end`) %in% 7:12 &
					year(`_start`) == year(`_end`)
				) ~ 2
			),
			
			# Semester (custom range)
			`_time_semester` = case_when(
				month(`_date`) %in% c(11:12, 1:4) |
				(
					month(`_start`) %in% c(11:12, 1:4) &
					( # Nov to Dec of this year
						month(`_end`) %in% 11:12 &
						year(`_end`) == year(`_start`)
					) |
					( # Jan to Apr of this or next year
						month(`_end`) %in% 1:4 &
						year(`_end`) == year(`_start`) |
						year(`_end`) == (year(`_start`) + 1)
					)
				) ~ 2, # Nov to Apr of next year
				month(`_date`) %in% 5:10 |
				(
					month(`_start`) %in% 5:10 &
					month(`_end`) %in% 5:10 &
					year(`_start`) == year(`_end`)
				) ~ 1 # May to Oct
			),
			
			# Year
			`_time_year` = `_year`
			
		)
	
	# For intervals between semesters, assign in max duration
	if (assign_semester) {
		out <- out %>%
			mutate( # add intervals for semesters and date
				`_assign_semester_1_interval_1` = interval( # sem 1 this year to next year
		            start = glue("{`_year`}-11-01") %>% as_date,
		            end = glue("{`_year` + 1}-04-30") %>% as_date
		        ),
				`_assign_semester_1_interval_2` = interval( # sem 1 last year to this year
		            start = glue("{`_year` - 1}-11-01") %>% as_date,
		            end = glue("{`_year`}-04-30") %>% as_date
		        ),
		        `_assign_semester_2_interval_1` = interval( # sem 2 next year
		            start = glue("{`_year` + 1}-05-01") %>% as_date,
		            end = glue("{`_year` + 1}-10-31") %>% as_date
		        ),
				`_assign_semester_2_interval_2` = interval( # sem 2 this year
		            start = glue("{`_year`}-05-01") %>% as_date,
		            end = glue("{`_year`}-10-31") %>% as_date
		        ),
				`_assign_date_interval` = if_else( # only for non-assigned sem
					!is.na(`_start`) & !is.na(`_end`) & is.na(`_time_semester`),
					interval(`_start`, `_end`),
					NA
				)
			) %>%
			mutate( # get duration in days
				`_assign_semester_1_days` = coalesce(
					intersect(
						`_assign_date_interval`,
						`_assign_semester_1_interval_1`
					),
					intersect(
						`_assign_date_interval`,
						`_assign_semester_1_interval_2`
					)
				) %>% as.numeric / (3600 * 24),
				`_assign_semester_2_days` = coalesce(
					intersect(
						`_assign_date_interval`,
						`_assign_semester_2_interval_1`
					),
					intersect(
						`_assign_date_interval`,
						`_assign_semester_2_interval_2`
					)
				) %>% as.numeric / (3600 * 24)
			) %>%
			mutate( # assign semester
				`_time_semester` = if_else(
					!is.na(`_assign_date_interval`),
					case_when(
						`_assign_semester_1_days` == `_assign_semester_2_days` ~ 2, # break ties to sem 2
						`_assign_semester_1_days` > `_assign_semester_2_days` ~ 1, # sem 1
						`_assign_semester_1_days` < `_assign_semester_2_days` ~ 2 # sem 2
					),
					`_time_semester`
				),
				`_assign_semester` = if_else(
					!is.na(`_assign_semester_1_days`) | !is.na(`_assign_semester_2_days`),
					TRUE,
					FALSE
				)
			) %>%
			select(-c( # remove unwanted cols
				`_assign_semester_1_interval_1`,
				`_assign_semester_1_interval_2`,
				`_assign_semester_2_interval_1`,
				`_assign_semester_2_interval_2`,
				`_assign_date_interval`
			))
	}
	
	# Add time groups that include the year
	out <- out %>%
		mutate(
			
			# Month group
			`_time_month_group` = if_else(
				!is.na(`_time_month`),
				glue("{`_year`}_{`_time_month`}"),
				NA
			),
			
			# Quarter group
			`_time_quarter_group` = if_else(
				!is.na(`_time_quarter`),
				glue("{`_year`}_{`_time_quarter`}"),
				NA
			),
			
			# Third group
			`_time_third_group` = if_else(
				!is.na(`_time_third`),
				glue("{`_year`}_{`_time_third`}"),
				NA
			),
			
			# Half group
			`_time_half_group` = if_else(
				!is.na(`_time_half`),
				glue("{`_year`}_{`_time_half`}"),
				NA
			),
			
			# Semester group
			`_time_semester_group` = if_else(
				!is.na(`_time_semester`),
				glue("{`_year`}_{`_time_semester`}"),
				NA
			),
			
			# Year group
			`_time_year_group` = if_else(
				!is.na(`_time_year`),
				glue("{`_year`}"),
				NA
			)
			
		)
	
	# Add prefix to time unit cols
	if (!is.null(prefix)) {
		out <- out %>%
			rename_with( # add prefix
				~ paste0(prefix, .x),
				starts_with("_time_")
			)
	}
	
	# Remove time cols
	out <- out %>%
		select(-c(
			`_date`,
			`_start`,
			`_end`,
			`_type`,
			`_year`
		))
	return(out)
}

```

### Bikeways

```{r}

# Add time unit columns using func for bikeways
bike <- bike %>%
	add_time_units( # install tunits
		date_col = "_install_verify_date",
		start_col = "_install_verify_date_start",
		end_col = "_install_verify_date_end",
		type_col = "_install_verify_date_type",
		year_col = "verify_install_year",
		prefix = "_install"
	) %>%
	add_time_units( # upgrade1 tunits
		date_col = "_upgrade1_verify_date",
		start_col = "_upgrade1_verify_date_start",
		end_col = "_upgrade1_verify_date_end",
		type_col = "_upgrade1_verify_date_type",
		year_col = "verify_upgrade1_year",
		prefix = "_upgrade1"
	) %>%
	add_time_units( # upgrade2 tunits
		date_col = "_upgrade2_verify_date",
		start_col = "_upgrade2_verify_date_start",
		end_col = "_upgrade2_verify_date_end",
		type_col = "_upgrade2_verify_date_type",
		year_col = "verify_upgrade2_year",
		prefix = "_upgrade2"
	)

# Display time unit cols for bikeways
bike %>%
	as_tibble %>%
	select(
		starts_with("_")
	) %>%
	arrange(`_install_verify_date`)

```

### KSI

```{r}

# Add time unit columns using func for ksi
ksi <- ksi %>%
	mutate( # add cols to standardize func params
		`_ksi_date` = ksi_date,
		`_ksi_date_start` = NA,
		`_ksi_date_end` = NA,
		`_ksi_date_type` = "day",
		`_ksi_year` = year(ksi_date)
	) %>%
	add_time_units(
		date_col = "_ksi_date",
		start_col = "_ksi_date_start",
		end_col = "_ksi_date_end",
		type_col = "_ksi_date_type",
		year_col = "_ksi_year",
		prefix = "_ksi_",
		assign_semester = F
	)

# Display time unit cols for ksi
ksi %>%
	as_tibble %>%
	select(
		ksi_date,
		starts_with("_")
	) %>%
	arrange(year(ksi_date))

```

## Filter Verified Post-2011 {.tabset}

Filter for bikeways and KSI with a verified installations after 2011.

### Bikeways

```{r}

# Filter bikeways for post2011
bike <- bike %>%
	filter(
		verify_install_year > 2011 |
		verify_upgrade1_year > 2011 |
		verify_upgrade2_year > 2011
	)

# Display filtered rows
bike %>%
	as_tibble %>%
	select(
		verify_install_year,
		verify_upgrade1_year,
		verify_upgrade2_year
	) %>%
	arrange(`verify_install_year`)

```

### KSI

```{r}

# Filter ksi for post2011
ksi <- ksi %>%
	filter(year(ksi_date) > 2011)

# Display filtered rows
ksi %>%
	as_tibble %>%
	select(ksi_date) %>%
	arrange(year(ksi_date))

```

## Determine Time Unit {.tabset .tabset-pills}

For bikeways, determine the temporal resolution (unit of time) finer than yearly based on the amount of data available per time unit (sorted from the highest resolution time unit to the lowest resolution time unit):

* **Month** (high): refers to verified post-2011 installs and upgrades occurring approximately in a month (1/12) of a year
* **Quarter**: refers to verified post-2011 installs and upgrades occurring approximately in a quarter (1/4) of a year
* **Third**: refers to verified post-2011 installs and upgrades occurring approximately in a third (1/3) of a year
* **Half** (low): refers to verified post-2011 installs and upgrades occurring approximately in a half (1/2) of a year
* **Semester** (low): refers to verified post-2011 installs and upgrades occurring approximately in a half (1/2) of a year with the first half (1) being November (same year) to April (next year) and the second half being May to October (next year)

```{r}

plot_time_units <- function(
		df,
		month_col = "_install_time_month",
		quarter_col = "_install_time_quarter",
		third_col = "_install_time_third",
		half_col = "_install_time_half",
		semester_col = "_install_time_semester",
		title = "% of Verified Post-2011 Installs by Unit of Time"
) {
	
	# Prepare plot data
	plot_data <- df %>%
		as_tibble %>%
		mutate( # assign time unit cols
			`_time_month` = .data[[month_col]],
			`_time_quarter` = .data[[quarter_col]],
			`_time_third` = .data[[third_col]],
			`_time_half` = .data[[half_col]],
			`_time_semester` = .data[[semester_col]]
		) %>%
		group_by(city) %>%
		summarize( # calc installs/upgrades for each time unit
			Month = sum(!is.na(`_time_month`)),
			Quarter = sum(!is.na(`_time_quarter`)),
			Third = sum(!is.na(`_time_third`)),
			Half = sum(!is.na(`_time_half`)),
			Semester = sum(!is.na(`_time_semester`))
		) %>%
		pivot_longer(
			cols = -city,
			names_to = "type",
			values_to = "n"
		) %>%
		mutate( # zero as NA
			n = if_else(n == 0, NA, n)
		) %>%
		left_join( # Add city totals
			df %>%
				as_tibble %>%
				group_by(city) %>%
				count(name = "total"),
			by = "city"
		) %>%
		ungroup %>%
	    mutate( # calc percentages and add labels
	        type = factor(type, levels = c("Month", "Quarter", "Third", "Half", "Semester")),
	        city = factor(str_to_title(city), levels = c("Vancouver", "Calgary", "Toronto")),
	        perc = n / total * 100,
	        perc_label = glue(
	        	"{str_sub(city, end = 1)}: {round(perc, 2)}%\n",
	        	"(n={format(n, big.mark = ',', scientific = F)})"
	        )
	    ) %>%
	    group_by(type) %>% # adjust overlapping labels
	    arrange(desc(perc)) %>% 
	    mutate( # detect overlap labels and shift down and up
	        perc_label_y = case_when(
	        	lag(perc) - perc < 2 ~ perc - 2,
	            lag(perc) - perc < 7 ~ perc - 1,
	            lead(perc) - perc > -2 ~ perc + 2,
	        	lead(perc) - perc > -7 ~ perc + 1,
	            .default = perc
	        )
	    ) %>%
		group_by(city) %>%
		mutate( # add city labels at end of lines
			city_label = if_else(
				type == "Semester",
				glue(
					"{city}\n",
					"(n={format(total, big.mark = ',', scientific = F)})"
				),
				NA
			)
		) %>%
		ungroup %>%
	    arrange(city, type)
	
	# Get time unit totals
	unit_total <- sum(plot_data$total %>% unique, na.rm = T)
	unit_total_label <- format(unit_total, big.mark = ",", scientific = F)
	
	# Plot time units
	out <- plot_data %>%
		ggplot(aes(
			x = type,
			y = perc,
			group = city,
			color = city,
			label = perc_label
		)) +
		geom_line(
			alpha = 0.8,
			linewidth = 1.5
		) +
		geom_label(
			aes(y = perc_label_y),
			size = 2.25,
			show.legend = F,
			label.padding = unit(0.5, "lines")
		) +
		geom_text(
			aes(
				label = city_label,
				y = perc_label_y
			),
			size = 2.5,
			show.legend = F,
			hjust = 0,
			nudge_x = 0.25
		) +
		scale_y_continuous(labels = function(x) paste0(x, "%")) +
		scale_x_discrete(
			limits = levels(plot_data$type),
			position = "top",
			expand = c(0.18, 0)
		) +
		labs(
			title = glue(
				"{title}\n",
				"(n={unit_total_label})"
			),
			x = NULL,
			y = NULL,
			color = "City",
			label = NULL,
			group = NULL
		) +
		theme_minimal() +
		theme(
			legend.position = "none",
			plot.title = element_text(hjust = 0.5)
		)
	return(out)
}

```

### Install

```{r}
plot_time_units(bike)
```

### 1st Upgrade

```{r}
plot_time_units(
	bike %>% filter(!is.na(verify_upgrade1_year)),
	month_col = "_upgrade1_time_month",
	quarter_col = "_upgrade1_time_quarter",
	third_col = "_upgrade1_time_third",
	half_col = "_upgrade1_time_half",
	semester_col = "_upgrade1_time_semester",
	title = "% of Verified Post-2011 1st Upgrades by Unit of Time"
)
```

### 2nd Upgrade

```{r}
plot_time_units(
	bike %>% filter(!is.na(verify_upgrade2_year)),
	month_col = "_upgrade2_time_month",
	quarter_col = "_upgrade2_time_quarter",
	third_col = "_upgrade2_time_third",
	half_col = "_upgrade2_time_half",
	semester_col = "_upgrade2_time_semester",
	title = "% of Verified Post-2011 2nd Upgrades by Unit of Time"
)
```

## Merge Bikeways {.tabset}

Merge bikeway segments if they are within the same infrastructure type, time unit, and known status (e.g. install, 1st upgrade, 2nd upgrade).

The known status is the most recent change **with a known time unit** for a segment with one of the following values:

1. `install`: an installed segment with no upgrades
2. `upgrade1` a segment upgraded once and was previously installed
3. `upgrade2`: a segment upgraded twice and was previously upgrade once and installed

This also adds an additional column `_merge_group` specifying the merge group in the format of `<CITYNUM>_<STATUS>_<TYPE>_<YEAR>_<TIME>_<ADJID>`, where:

* `<CITYNUM>`: is the numeric id of the city, 1 is vancouver, 2 is calgary, and 3 is toronto
* `<STATUS>`: the status of the segment, one of `install`, `upgrade1`, or `upgrade2`
* `<TYPE>`: the infrastructure type of the segment
* `<YEAR>`: the year of the segment status
* `<TIME>`: the value of the time unit
* `<ADJID>`: the adjacency id, if the ids are the same, they are adjacent in space

Other merge related columns start with `_merge_...`.

```{r}

# Select time unit
tunit <- "semester"

# Determine adjacent segments if they are within same status, type, and time unit
bike <- bike %>%
	filter( # remove segments that do not have the time unit
		!is.na(.data[[glue("_upgrade2_time_{tunit}")]]) |
		!is.na(.data[[glue("_upgrade1_time_{tunit}")]]) |
		!is.na(.data[[glue("_install_time_{tunit}")]])
	) %>%
	mutate( # add column to store status, type, and time unit
		`_merge_status` = case_when(
			!is.na(.data[[glue("_upgrade2_time_{tunit}")]]) ~ "upgrade2",
			!is.na(.data[[glue("_upgrade1_time_{tunit}")]])~ "upgrade1",
			!is.na(.data[[glue("_install_time_{tunit}")]]) ~ "install"
		),
		`_merge_type` = case_when(
			`_merge_status` == "upgrade2" ~ verify_upgrade2_type,
			`_merge_status` == "upgrade1" ~ verify_upgrade1_type,
			`_merge_status` == "install" ~ verify_install_type
		),
		`_merge_time_unit` = tunit,
		`_merge_time` = case_when(
			`_merge_status` == "upgrade2" ~ .data[[glue("_upgrade2_time_{tunit}")]],
			`_merge_status` == "upgrade1" ~ .data[[glue("_upgrade1_time_{tunit}")]],
			`_merge_status` == "install" ~ .data[[glue("_install_time_{tunit}")]]
		),
		`_merge_time_group` = case_when(
			`_merge_status` == "upgrade2" ~ .data[[glue("_upgrade2_time_{tunit}_group")]],
			`_merge_status` == "upgrade1" ~ .data[[glue("_upgrade1_time_{tunit}_group")]],
			`_merge_status` == "install" ~ .data[[glue("_install_time_{tunit}_group")]]
		),
		`_merge_year` = case_when(
			`_merge_status` == "upgrade2" ~ `_upgrade2_time_year`,
			`_merge_status` == "upgrade1" ~ `_upgrade1_time_year`,
			`_merge_status` == "install" ~ `_install_time_year`
		)
	) %>%
	group_by(city, `_merge_status`, `_merge_type`, `_merge_time_group`) %>%
	group_map(~ {
		
		# Assign group id as group_by values separated by underscore
		group_id <- .y[1,] %>%
			as.character %>%
			paste0(., collapse = "_") %>%
			str_to_lower(.)
		
		# Find adjacent segments and group them together using a group id
		adj_group <- .x %>%
			st_touches %>%
			graph_from_adj_list %>%
			components %>%
			.$membership %>%
			paste0(group_id, "_", .)
		
		# Assign adj group to data in order
		out <- .x %>% mutate(`_merge_group` = adj_group)
		return(out)
		
	}, .keep = T) %>%
	reduce(add_row)

# Merge bike segments by adjacency
bike_merge <- bike %>%
	group_by(`_merge_group`) %>%
	summarize(
		id = paste0(id, collapse = ","),
		city = paste0(unique(city), collapse = ","),
		status = case_when( # assign single status if possible
			all(unique(`_merge_status`) == "upgrade2") ~ "upgrade2",
			all(unique(`_merge_status`) == "upgrade1") ~ "upgrade1",
			all(unique(`_merge_status`) == "install") ~ "install",
			.default = paste(unique(`_merge_status`), collapse = ",") # multiple status
		),
		type = if_else( # assign single type if possible
			length(unique(`_merge_type`)) == 1,
			unique(`_merge_type`) %>% as.character, # single type
			paste(unique(`_merge_type`), collapse = ",") # multiple types
		),
		year = if_else( # assign single year if possible
			length(unique(`_merge_year`)) == 1,
			unique(`_merge_year`) %>% as.character, # single year
			paste(unique(`_merge_year`), collapse = ",") # multiple years
		),
		time_unit = tunit,
		time_value = if_else( # assign single time if possible
			length(unique(`_merge_time`)) == 1,
			unique(`_merge_time`) %>% as.character, # single time
			paste(unique(`_merge_time`), collapse = ",") # multiple times
		),
		time_group = if_else( # assign single time if possible
			length(unique(`_merge_time_group`)) == 1,
			unique(`_merge_time_group`) %>% as.character, # single time
			paste(unique(`_merge_time_group`), collapse = ",") # multiple times
		)
	)

```

### Map

```{r}
tmap_mode("view")
tm_shape(bike_merge %>% st_buffer(25)) +
    tm_polygons(
    	group = "Merged (Black)",
    	col = "black",
    	border.col = "white",
    	popup.vars = T,
    	lwd = 1.5
    ) +
	tm_shape(bike) +
	tm_lines(
		group = "Segments (Red)",
		col = "red",
		lwd = 1.5
	) +
	tm_shape(bike %>% st_cast("POINT")) +
	tm_dots(group = NULL, col = "red", size = 0.03)
```

### Data

```{r}
# Display merged bike segments
bike_merge %>%
	as_tibble %>%
	select(-geometry)
```

## Join KSI to Bikeways {.tabset}

Spatially join KSI to nearest bikeways.

Each KSI point is joined to a bikeway if they are within 25 meters of the nearest bikeway

**Note**: if there is overlapping of bikeways, the same KSI can be assigned to multiple bikeways.

```{r}

# Set cache file for spatiotemp join
sjoin_date <- max(c(
	vancbike_dldate,
	calgbike_dldate,
	toronbike_dldate,
	toronksi_dldate
))
sjoin_file <- glue("../data/cache/sjoin-{sjoin_date}.csv")

# Run spatial join if not cached
if (!file.exists(sjoin_file)) {
	
	# Buffer bikeways and keep ids
	bike_merge_buff25 <- bike_merge %>%
		select(city, id) %>%
		st_buffer(25)
	
	# Spatial join bikeways with ksi keeping ids
	sjoin <- bike_merge_buff25 %>%
		st_join(ksi %>% select(ksi_id)) %>%
		as_tibble %>%
		select(-geometry)
	
	# Cache spatial joined bike and ksi ids
	sjoin %>% write_csv(sjoin_file)
	
} else {
	
	# Read spatial joined bike and ksi ids from cache
	sjoin <- read_csv(sjoin_file, col_types = cols(id = "c"))
	
}
```

## Count KSI Per Time Unit {.tabset}

For each bikeway and event type (install, upgrade 1, upgrade 2), count KSI spatially joined to bikeways per unit of time across years.

This creates columns in the format of `_ksi_time_<UNIT>_<YEAR>_<VALUE>`, where:

* `<UNIT>`: is the unit of time, either `month`, `quarter`, `half`, or `semester`
* `<YEAR>`: is the year for the unit of time
* `<VALUE>`: is the number representing the portion of the time range for the unit of time with month being 1-12, quarter being 1-4, third being 1-3, half being 1-2 and semester being 1-2 (this is omitted if time unit is `year`)

```{r}

# Count ksi spatially joined to bike
for (tunit in c("month", "third", "quarter", "half", "semester", "year")) {
	
	# Count ksi by unit of time for each bike event
	sjoin_count <- sjoin %>%
	    mutate(
	        city = as.character(city),
	        id = as.character(id),
	        ksi_id = as.character(ksi_id)
	    ) %>%
	    left_join(bike_merge, by = c("city", "id")) %>%
	    left_join(ksi, by = "ksi_id") %>%
	    group_by(city, id, event, across(glue("_ksi_time_{tunit}_group"))) %>%
	    count %>%
	    ungroup
	
	# Pivot to wider format with each col being a time unit
	sjoin_count_wide <- sjoin_count %>%
	    pivot_wider(
	        names_from = glue("_ksi_time_{tunit}_group"),
	        values_from = "n",
	        names_prefix = glue("_ksi_time_{tunit}_")
	    ) %>%
	    rename_with(
	        str_to_lower,
	        ends_with("_NA")
	    )
	
	# Gen all possible year and time value combinations
	year_min <- min(year(ksi$DATE), na.rm = T)
	year_max <- max(year(ksi$DATE), na.rm = T)
	value_max <- switch(
		tunit,
		month = 12,
		third = 3,
		quarter = 4,
		half = 2,
		semester = 2,
		year = 1,
		stop("Invalid value for tunit")
	)
	tunit_cols <- expand.grid(
		year = year_min:year_max,
		value = 1:value_max,
		unit = tunit
	) %>%
	    mutate(
	    	column = if_else(
	    		unit != "year",
	    		glue("_ksi_time_{tunit}_{year}_{value}"),
	    		glue("_ksi_time_{tunit}_{year}")
	    	)
	    ) %>%
	    arrange(year, value) %>%
	    pull(column)
	
	# Add missing year and value combos
	tunit_miss <- tunit_cols[!tunit_cols %in% names(sjoin_count_wide)]
	has_tunit_miss <- length(tunit_miss) > 0
	if (has_tunit_miss) {
		sjoin_count_wide <- sjoin_count_wide %>%
			add_column(!!!setNames(
				rep(0, length(tunit_miss)),
				tunit_miss
			))
	}
	
	# Sort by time unit
	sjoin_count_wide <- sjoin_count_wide %>%
		select(
			city,
			id,
			event,
			all_of(tunit_cols)
		)

	# Add counts back into bike and set nas to zeroes
	bike_merge <- bike_merge %>%
		left_join(
			sjoin_count_wide,
			by = c("city", "id", "event")
		) %>%
		mutate(across(
			all_of(tunit_cols),
			~replace_na(., 0)
		))
}

# Display ksi counts per bike and time unit
bike_merge %>%
	as_tibble %>%
	select(-geometry) %>%
	select(
		id,
		city,
		event,
		type,
		year,
		semester,
		starts_with("_ksi_time_semester")
	)

```
