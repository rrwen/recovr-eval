---
title: "Cycling Interventions Evaluation"
subtitle: "R Code"
author:
- "Richard Wen richard.wen@utoronto.ca"
- "Brice Batomen brice.kuimi@utoronto.ca"
- "Linda Rothman linda.rothman@torontomu.ca"
- "Andrew Howard andrew.howard@sickkids.ca"
date: "`r format(Sys.time(), '%B %d, %Y')`"
knit: |
    (function(input_rmd, ...) {
    rmarkdown::render(
        input_rmd,
        rmarkdown::html_document(
            toc = TRUE,
            toc_float = TRUE,
            highlight = "zenburn",
            code_folding = "hide",
            df_print = "paged",
            self_contained = FALSE
        ),
        output_dir = "../docs",
        output_file = "index", ...)
    })
---

```{r include = FALSE, echo = FALSE}
knitr::opts_chunk$set(
	warning = FALSE,
	message = FALSE
)
```

# Installation

1.  Install [R](https://www.r-project.org/)
2.  Install [RTools](https://cran.r-project.org/) if you are on Windows
3.  Install [RStudio](https://posit.co/download/rstudio-desktop/)

For more details, see [Software and Package Versions](#software-and-package-versions).

# Running This Code

1.  Ensure the installation steps above are completed
2.  Download a zip of the code and data [here](https://github.com/rrwen/recovr-eval/archive/refs/heads/main.zip) and unzip it
    - Code Repository: [github.com/rrwen/recovr-eval](https://github.com/rrwen/recovr-eval)
3.  In RStudio, open the [src/src.Rproj](https://github.com/rrwen/recovr-eval/blob/main/src/src.Rproj) file
4.  Then, open the [src/index.Rmd](https://github.com/rrwen/recovr-eval/blob/main/src/index.Rmd) file
5.  In RStudio:
    - Run all code: Click the `Run` drop down (top right of the code pane) and click `Run All`
    - Generate HTML version: Click `knit` (top left of code pane) and a file will be generated in `docs/index.html`

# Libraries

Install R packages if needed.

```{r, results = FALSE}

# Required packages
required_packages <- c(
	"rmarkdown",
	"bookdown",
	"knitr",
	"tidyverse",
	"purrr",
	"glue",
	"lubridate",
	"scales",
	"patchwork",
	"DiagrammeR",
	"DiagrammeRsvg",
	"webshot2",
	"magick",
	"rsvg",
	"sf",
	"tmap",
	"ggspatial",
	"prettymapr",
	"units",
	"boot"
)

# Try to install packages if not installed
default_options <- options()
tryCatch(
	{
		# Disable interactivity
		options(install.packages.compile.from.source = "always")
		
		# Install package if not installed
		for (package in required_packages) {
			is_package_installed <- require(package, character.only = TRUE)
			if (!is_package_installed) {
				cat(paste0("Installing package: ", package, "\n"))
				install.packages(package)
			} else {
				cat(paste0("Package already installed: ", package, "\n"))
			}
		}
	},
	error = function(cond) {
		stop(cond)
	},
	finally = {
		options(default_options) # reset interactivity
	}
)
```

Load R libraries.

```{r}
library(boot)
library(DiagrammeR)
library(ggplot2)
library(ggspatial)
library(glue)
library(lubridate)
library(patchwork)
library(sf)
library(tidyverse)
library(tmap)
```

# Data

Read data from the `data` folder.

```{r}
ddesc <- read_csv("../data/data.csv")
ddesc
```

## Vancouver Bikeways {.tabset}

`r ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "vancouver-bikeways-2024-06-02.geojson") %>% pull(notes)`

```{r}

# Read data
vancbike_raw <- read_sf("../data/vancouver-bikeways-2024-06-02.geojson")

# Get download date
vancbike_dldate <- ddesc %>% filter(
	file == "vancouver-bikeways-2024-06-02.geojson"
) %>% pull(download_date)
```

### Map

Only the first 1000 records are shown.

```{r}
tmap_mode("view")
tm_shape(vancbike_raw %>% head(1000)) +
    tm_lines(
    	col = "#336699",
    	border.col = "white",
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(vancbike_raw)`
* Rows: `r nrow(vancbike_raw)`

```{r}
vancbike_raw %>% as_tibble
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
#vancbike_ddict <- read_csv("../data/vancouver-bikeways-2024-06-02-datadict.csv")
#vancbike_ddict
```

### Details

```{r}
print(vancbike_raw)
```

### Files

The data files are available below:

- [vancouver-bikeways-2024-06-02.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/vancouver-bikeways-2024-06-02.geojson)
- [vancouver-bikeways-2024-06-02-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/vancouver-bikeways-2024-06-02-datadict.csv)

## Calgary Bikeways {.tabset}

`r ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "calgary-bikeways-2024-06-05.geojson") %>% pull(notes)`

```{r}

# Read data
calgbike_raw <- read_sf("../data/calgary-bikeways-2024-06-05.geojson")

# Get download date
calgbike_dldate <- ddesc %>% filter(
	file == "calgary-bikeways-2024-06-05.geojson"
) %>% pull(download_date)
```

### Map

Only the first 1000 records are shown.

```{r}
tmap_mode("view")
tm_shape(calgbike_raw %>% head(1000)) +
    tm_lines(
    	col = "#336699",
    	border.col = "white",
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(calgbike_raw)`
* Rows: `r nrow(calgbike_raw)`

```{r}
calgbike_raw %>% as_tibble
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
#calgbike_ddict <- read_csv("../data/calgary-bikeways-2024-06-05-datadict.csv")
#calgbike_ddict
```

### Details

```{r}
print(calgbike_raw)
```

### Files

The data files are available below:

- [calgary-bikeways-2024-06-05.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/calgary-bikeways-2024-06-05.geojson)
- [calgary-bikeways-2024-06-05-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/calgary-bikeways-2024-06-05-datadict.csv)

## Toronto Bikeways {.tabset}

`r ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "toronto-bikeways-2024-06-02.geojson") %>% pull(notes)`

```{r}

# Read data
toronbike_raw <- read_sf("../data/toronto-bikeways-2024-06-02.geojson")

# Get download date
toronbike_dldate <- ddesc %>% filter(
	file == "toronto-bikeways-2024-06-02.geojson"
) %>% pull(download_date)
```

### Map

Only the first 1000 records are shown.

```{r}
tmap_mode("view")
tm_shape(toronbike_raw %>% head(1000)) +
    tm_lines(
    	col = "#336699",
    	border.col = "white",
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(toronbike_raw)`
* Rows: `r nrow(toronbike_raw)`

```{r}
toronbike_raw %>% as_tibble
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
#toronbike_ddict <- read_csv("../data/toronto-bikeways-2024-06-02-datadict.csv")
#toronbike_ddict
```

### Details

```{r}
print(toronbike_raw)
```

### Files

The data files are available below:

- [toronto-bikeways-2024-06-02.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-bikeways-2024-06-02.geojson)
- [toronto-bikeways-2024-06-02-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-bikeways-2024-06-02-datadict.csv)

## Verified Dates {.tabset}

`r ddesc %>% filter(file == "verify-dates-2024-06-07.csv") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "verify-dates-2024-06-07.csv") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "verify-dates-2024-06-07.csv") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "verify-dates-2024-06-07.csv") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "verify-dates-2024-06-07.csv") %>% pull(notes)`

```{r}

# Read data
vdates_raw <- read_csv("../data/verify-dates-2024-06-07.csv")

# Get download date
vdates_dldate <- ddesc %>% filter(
	file == "verify-dates-2024-06-07.csv"
) %>% pull(download_date)
```

### Data

* Columns: `r ncol(vdates_raw)`
* Rows: `r nrow(vdates_raw)`

```{r}
vdates_raw
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
vdates_ddict <- read_csv("../data/verify-dates-2024-06-07-datadict.csv")
vdates_ddict
```

### Files

The data files are available below:

- [verify-dates-2024-06-07.csv](https://github.com/rrwen/recovr-eval/blob/main/data/verify-dates-2024-06-07.csv)
- [verify-dates-2024-06-07-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/verify-dates-2024-06-07-datadict.csv)

## Toronto KSI {.tabset}

`r ddesc %>% filter(file == "toronto-ksi-2024-06-01.geojson") %>% pull(description)`

* **Download Link**: `r ddesc %>% filter(file == "toronto-ksi-2024-06-01.geojson") %>% pull(url)`
* **Download Date**: `r format(ddesc %>% filter(file == "toronto-ksi-2024-06-01.geojson") %>% pull(download_date), '%B %d, %Y')`
* **Data Updated**: `r format(ddesc %>% filter(file == "toronto-ksi-2024-06-01.geojson") %>% pull(update_date), '%B %d, %Y')`
* **Notes**: `r ddesc %>% filter(file == "toronto-ksi-2024-06-01.geojson") %>% pull(notes)`

```{r}

# Read data
ksi_raw <- read_sf("../data/toronto-ksi-2024-06-01.geojson")

# Get download date
ksi_dldate <- ddesc %>% filter(
	file == "toronto-ksi-2024-06-01.geojson"
) %>% pull(download_date)
```

### Map

**Note**: Due to the large number of records, only the latest year of `r year(max(ksi_raw$DATE))` is displayed (n = `r ksi_raw %>% filter(year(DATE) == max(year(DATE))) %>% nrow`).

```{r}
tmap_mode("view")
tm_shape(ksi_raw %>% filter(year(DATE) == max(year(DATE)))) +
    tm_dots(
    	col = "ACCLASS",
    	clustering = TRUE,
    	popup.vars = TRUE
    )
```

### Data

* Columns: `r ncol(ksi_raw)`
* Rows: `r nrow(ksi_raw)`

```{r}
ksi_raw %>% as_tibble()
```

### Dictionary

The data contains the following columns:

```{r, cols.print = 3}
ksi_ddict <- read_csv("../data/toronto-ksi-2024-06-01-datadict.csv")
ksi_ddict
```

### Details

```{r}
print(ksi_raw)
```

### Files

The data files are available below:

- [toronto-ksi-2024-06-01.geojson](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-ksi-2024-06-01.geojson)
- [toronto-ksi-2024-06-01-datadict.csv](https://github.com/rrwen/recovr-eval/blob/main/data/toronto-ksi-2024-06-01-datadict.csv)

# Cleaning

## Combine Bikeways {.tabset}

Combine bikeway data across all cities.

```{r}

# List of city bikeway data
bike_list <- list(
	vancouver = vancbike_raw,
	calgary = calgbike_raw %>%
		mutate(no_verify_install_type = NA),
	toronto = toronbike_raw %>%
		mutate(no_verify_install_type = NA)
)

# Get common columns across all city bikeways
bike_cols <- bike_list %>%
	map(colnames) %>%
	reduce(intersect)

# Combine bikeway data across cities
bike <- names(bike_list) %>%
	map(function(city) {
		bike_list[[city]] %>%
			select(
				all_of(bike_cols)
			) %>%
			mutate(
				city = factor(city, levels = names(bike_list)),
				.before = 1
			)
	}) %>%
	reduce(add_row)
```

## Join Clean Dates

Join ambiguous verified install/upgrade dates (e.g. Jan 1/2022, 2022/02, Fall 2020) to manually cleaned dates with structured time units (e.g. days, months, quarters, semesters, ranges) and date formats (e.g. 2022-01-01, 2022-02-01).

Each of `verify_install_date`, `verify_upgrade1_date` and `verify_upgrade2_date` will have a set of cleaned structured date columns:

`r cat(paste0("\n * ", colnames(vdates)))`

```{r}

# Join clean dates to include structured date formats
bike <- bike %>%
	left_join( # join to installs
		vdates_raw %>%
			rename_with(
				~ paste0("install_", .x),
				everything()
			),
		by = join_by(verify_install_date == install_verify_date_raw)
	) %>%
	left_join( # join to upgrade1
		vdates_raw %>%
			rename_with(
				~ paste0("upgrade1_", .x),
				everything()
			),
		by = join_by(verify_upgrade1_date == upgrade1_verify_date_raw)
	) %>%
	left_join( # join to upgrade2
		vdates_raw %>%
			rename_with(
				~ paste0("upgrade2_", .x),
				everything()
			),
		by = join_by(verify_upgrade2_date == upgrade2_verify_date_raw)
	)

```

## Add Columns

Add the following filter columns:

* `_is_verify`: if a bikeway had a verified installation or upgrade
* `_is_verify_post2018`: if a bikeway had a verified installation or upgrade after 2018
* `_is_verify_dated`: if a bikeway had a verified installation or upgrade with dates
* `_is_verify_cdated`: if a bikeway had a verified installation or upgrade with cleaned dates

Then add the following finest time unit columns for installs/upgrades:

* `install_verify_date_month`: which month (1, 2, 3 ... 12) a bikeway had verified installation
* `install_verify_date_quarter`: which quarter (1, 2, 3, 4) of the year a bikeway had verified installation
* `install_verify_date_third`: which third (1, 2, 3) of the year a bikeway had verified installation
* `install_verify_date_half`: which half (1, 2) of the year a bikeway had verified installation
* `upgrade1_verify_date_month`: which month (1, 2, 3 ... 12) a bikeway had verified 1st upgrade
* `upgrade1_verify_date_quarter`: which quarter (1, 2, 3, 4) of the year a bikeway had verified 1st upgrade
* `upgrade1_verify_date_third`: which third (1, 2, 3) of the year a bikeway had verified 1st upgrade
* `upgrade1_verify_date_half`: which half (1, 2) of the year a bikeway had verified 1st upgrade
* `upgrade2_verify_date_month`: which month (1, 2, 3 ... 12) a bikeway had verified 2nd upgrade
* `upgrade2_verify_date_quarter`: which quarter (1, 2, 3, 4) of the year a bikeway had verified 2nd upgrade
* `upgrade2_verify_date_third`: which third (1, 2, 3) of the year a bikeway had verified 2nd upgrade
* `upgrade2_verify_date_half`: which half (1, 2) of the year a bikeway had verified 2nd upgrade

```{r}

# Add filter columns
vbike <- bike %>%
	mutate(
		`_is_verify` =
			(!is.na(verify_install_year) |
			 !is.na(verify_upgrade1_year) |
			 !is.na(verify_upgrade2_year)) &
			is.na(no_verify_install_type),
		`_is_very_post2018` = 
			verify_install_year > 2018 |
			verify_upgrade1_year > 2018 |
			verify_upgrade2_year > 2018,
		`is_verify_dated` =
			!is.na(verify_install_date) |
			!is.na(verify_upgrade2_date) |
			!is.na(verify_upgrade2_date),
		`is_verify_cdated` = 
			!is.na(install_verify_date_type) |
			!is.na(upgrade1_verify_date_type) |
			!is.na(upgrade2_verify_date_type)
	)

# Add time unit columns for month, quarter, third, half
for (event in c("install", "upgrade1", "upgrade2")) {
	
	# Date col name
	date_col <- glue("{event}_verify_date")
	start_col <- glue("{event}_verify_date_start")
	end_col <- glue("{event}_verify_date_end")
	type_col <- glue("{event}_verify_date_type")
	
	# Time unit col name
	month_col <- glue("{event}_verify_date_month")
	quarter_col <- glue("{event}_verify_date_quarter")
	third_col <- glue("{event}_verify_date_third")
	half_col <- glue("{event}_verify_date_half")
	
	# Add time unit columns via mutate
	bike <- bike %>%
		mutate(
			!!month_col := case_when(
				.data[[type_col]] %in% c("day", "month") ~ month(.data[[date_col]], label = T, abbr = F)
			),
			!!quarter_col := case_when( # classify quarterly
				month(.data[[date_col]]) %in% 1:3 |
				(
					month(.data[[start_col]]) %in% 1:3 &
					month(.data[[end_col]]) %in% 1:3 &
					year(.data[[start_col]]) == year(.data[[end_col]])
				) ~ 1,
				month(.data[[date_col]]) %in% 4:6 |
				(
					month(.data[[start_col]]) %in% 4:6 &
					month(.data[[end_col]]) %in% 4:6 &
					year(.data[[start_col]]) == year(.data[[end_col]])
				) ~ 2,
				month(.data[[date_col]]) %in% 1:3 |
				(
					month(.data[[start_col]]) %in% 7:9 &
					month(.data[[end_col]]) %in% 7:9 &
					year(.data[[start_col]]) == year(.data[[end_col]])
				) ~ 3,
				month(.data[[date_col]]) %in% 10:12 |
				(
					month(.data[[start_col]]) %in% 10:12 &
					month(.data[[end_col]]) %in% 10:12 &
					year(.data[[start_col]]) == year(.data[[end_col]])
				) ~ 4
			),
			!!third_col := case_when( # classify triyearly
				month(.data[[date_col]]) %in% 1:4 |
				(
					month(.data[[start_col]]) %in% 1:4 &
					month(.data[[end_col]]) %in% 1:4 &
					year(.data[[start_col]]) == year(.data[[end_col]])
				) ~ 1, # Fall
				month(.data[[date_col]]) %in% 5:8 |
				(
					month(.data[[start_col]]) %in% 5:8 &
					month(.data[[end_col]]) %in% 5:8 &
					year(.data[[start_col]]) == year(.data[[end_col]])
				) ~ 2, # Winter
				month(.data[[date_col]]) %in% 9:12 |
				(
					month(.data[[start_col]]) %in% 9:12 &
					month(.data[[end_col]]) %in% 9:12 &
					year(.data[[start_col]]) == year(.data[[end_col]])
				) ~ 3 # Spring/Summer
			),
			!!half_col := case_when( # classify biyearly
				month(.data[[date_col]]) %in% 1:6 |
				(
					month(.data[[start_col]]) %in% 1:6 &
					month(.data[[end_col]]) %in% 1:6 &
					year(.data[[start_col]]) == year(.data[[end_col]])
				) ~ 1,
				month(.data[[date_col]]) %in% 7:12 |
				(
					month(.data[[start_col]]) %in% 7:12 &
					month(.data[[end_col]]) %in% 7:12 &
					year(.data[[start_col]]) == year(.data[[end_col]])
				) ~ 2
			)
		)
}

```

## Determine Unit of Time

Determine the unit of time based on the amount of data available per time unit.

Use a unit of time other than year.

```{r fig.height = 11, fig.width = 6}
unit_plot_data <- clean_nrow %>%
    select(
        "City",
        "Monthly Installs",
        "Monthly Upgrades (1st)",
        "Monthly Upgrades (2nd)",
        "Quarterly Installs",
        "Quarterly Upgrades (1st)",
        "Quarterly Upgrades (2nd)",
        "Triyearly Installs",
        "Triyearly Upgrades (1st)",
        "Triyearly Upgrades (2nd)",
        "Biyearly Installs",
        "Biyearly Upgrades (1st)",
        "Biyearly Upgrades (2nd)",
        "Monthly Installs % of Verified Post-2018",
        "Monthly Upgrades % of Verified Post-2018 (1st)",
        "Monthly Upgrades % of Verified Post-2018 (2nd)",
        "Quarterly Installs % of Verified Post-2018",
        "Quarterly Upgrades % of Verified Post-2018 (1st)",
        "Quarterly Upgrades % of Verified Post-2018 (2nd)",
        "Triyearly Installs % of Verified Post-2018",
        "Triyearly Upgrades % of Verified Post-2018 (1st)",
        "Triyearly Upgrades % of Verified Post-2018 (2nd)",
        "Biyearly Installs % of Verified Post-2018",
        "Biyearly Upgrades % of Verified Post-2018 (1st)",
        "Biyearly Upgrades % of Verified Post-2018 (2nd)"
    ) %>%
    pivot_longer(
        cols = contains("%"),
        names_to = "Column",
        values_to = "% of Verified Post-2018 Segments"
    ) %>%
    mutate(
        Type = case_when(
            str_detect(Column, "Installs") ~ "Installs",
            str_detect(Column, "\\(1st\\)") ~ "Upgrades (1st)",
            str_detect(Column, "\\(2nd\\)") ~ "Upgrades (2nd)"
        ),
        `Unit of Time` = case_when(
        	str_starts(Column, "Monthly") ~ "Monthly",
        	str_starts(Column, "Quarterly") ~ "Quarterly",
        	str_starts(Column, "Triyearly") ~ "Triyearly",
        	str_starts(Column, "Biyearly") ~ "Biyearly"
        ),
        `Unit of Time` = factor(
        	`Unit of Time`,
        	levels = rev(c(
        		"Monthly",
        		"Quarterly",
        		"Triyearly",
        		"Biyearly"
        	))
        ),
        Segments = case_when(
        	`Unit of Time` == "Monthly" & Type == "Installs" ~ `Monthly Installs`,
        	`Unit of Time` == "Monthly" & Type == "Upgrades (1st)" ~ `Monthly Upgrades (1st)`,
        	`Unit of Time` == "Monthly" & Type == "Upgrades (2nd)" ~ `Monthly Upgrades (2nd)`,
        	`Unit of Time` == "Quarterly" & Type == "Installs" ~ `Quarterly Installs`,
        	`Unit of Time` == "Quarterly" & Type == "Upgrades (1st)" ~ `Quarterly Upgrades (1st)`,
        	`Unit of Time` == "Quarterly" & Type == "Upgrades (2nd)" ~ `Quarterly Upgrades (2nd)`,
        	`Unit of Time` == "Triyearly" & Type == "Installs" ~ `Triyearly Installs`,
        	`Unit of Time` == "Triyearly" & Type == "Upgrades (1st)" ~ `Triyearly Upgrades (1st)`,
        	`Unit of Time` == "Triyearly" & Type == "Upgrades (2nd)" ~ `Triyearly Upgrades (2nd)`,
        	`Unit of Time` == "Biyearly" & Type == "Installs" ~ `Biyearly Installs`,
        	`Unit of Time` == "Biyearly" & Type == "Upgrades (1st)" ~ `Biyearly Upgrades (1st)`,
        	`Unit of Time` == "Biyearly" & Type == "Upgrades (2nd)" ~ `Biyearly Upgrades (2nd)`
        ),
        Label = if_else(
        	`% of Verified Post-2018 Segments` > 0,
        	glue("{`Unit of Time`}\n(n={`Segments`}, {round(`% of Verified Post-2018 Segments`, 2)}%)"),
        	NA
        )
    )

ggplot(
	unit_plot_data,
	aes(
		x = City,
		y = `% of Verified Post-2018 Segments`,
		group = `Unit of Time`,
		fill = `Unit of Time`
	)
) +
	geom_bar(
		stat = "identity",
		position = "dodge"
	) +
	geom_text(
		aes(label = Label, y = -2),
		position = position_dodge(width = 0.9),
		hjust = 1,
		vjust = 0.5,
		size = 1.75
	) +
	facet_wrap(
		~Type,
		ncol = 1
	) +
	scale_fill_discrete(
		guide = guide_legend(reverse = TRUE)
	) +
	ylim(-10, 60) +
	theme_minimal() +
	theme(
		legend.position = "none"
	) +
	coord_flip()
```
